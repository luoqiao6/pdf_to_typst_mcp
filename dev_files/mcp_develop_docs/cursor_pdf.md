# å¯»æ‰¾å¯å¤„ç†pdfçš„å…¶ä»–å¤§æ¨¡å‹
_Exported on 2025/9/6 at GMT+8 18:21:07 from Cursor (1.5.11)_

---

**User**

é™¤äº† Claude.aiã€ChatGPT ã€Gemini è¿™ä¸‰ä¸ªå¤§æ¨¡å‹å¯ä»¥ç›´æ¥è¯†åˆ«pdfæ–‡ä»¶çš„å†…å®¹å’Œé¡µé¢æ’ç‰ˆå¸ƒå±€ï¼Œè¿˜æœ‰å…¶ä»–å¤§æ¨¡å‹å¯é€‰å—ã€‚æœ‰äº›å¤§æ¨¡å‹å¯èƒ½ä¸èƒ½ç›´æ¥è¯»å–pdfæ–‡ä»¶ï¼Œä½†å¯ä»¥è¯»å–markdownè¿™æ ·çš„æ–‡æœ¬æ–‡ä»¶å’Œå›¾ç‰‡ï¼Œè¿™æ ·å¯ä»¥å…ˆæŠŠpdfè½¬æ¢ä¸ºæ–‡æœ¬å’Œå›¾ç‰‡æä¾›ç»™è¿™æ ·çš„å¤§æ¨¡å‹ï¼Œè®©å…¶ç”ŸæˆTypstæ–‡ä»¶ã€‚æ–‡æœ¬æ–‡ä»¶ç¼ºå°‘é¡µé¢æ’ç‰ˆå¸ƒå±€ä¿¡æ¯ï¼Œå›¾ç‰‡ä¿ç•™äº†åŸpdfçš„é¡µé¢æ’ç‰ˆä¿¡æ¯ï¼Œä¸¤è€…å¯ä»¥ç›¸äº’è¡¥å……ï¼Œä¹Ÿå¯ä»¥é¿å…åªé€šè¿‡å›¾ç‰‡è¯†åˆ«é¡µé¢ä¸­çš„æ–‡å­—å¯¼è‡´çš„æ–‡å­—å¯èƒ½è¯†åˆ«é”™è¯¯çš„é—®é¢˜ã€‚

---

**Cursor**

æ‚¨æå‡ºäº†ä¸€ä¸ªå¾ˆå¥½çš„æŠ€æœ¯æ–¹æ¡ˆæ€è·¯ï¼è®©æˆ‘ä¸ºæ‚¨åˆ†æä¸€ä¸‹å¯ç”¨çš„å¤šæ¨¡æ€å¤§æ¨¡å‹é€‰é¡¹ï¼Œä»¥åŠå¦‚ä½•å®ç°PDFè½¬æ¢ä¸ºæ–‡æœ¬+å›¾ç‰‡çš„æ–¹æ¡ˆã€‚

æ ¹æ®æˆ‘çš„è°ƒç ”ï¼Œé™¤äº†æ‚¨æåˆ°çš„ Claude.aiã€ChatGPT å’Œ Geminiï¼Œè¿˜æœ‰å¾ˆå¤šä¼˜ç§€çš„å¤šæ¨¡æ€å¤§æ¨¡å‹å¯ä»¥é€‰æ‹©ã€‚è®©æˆ‘ä¸ºæ‚¨æ•´ç†ä¸€ä¸‹ï¼š

## å¼€æºå¤šæ¨¡æ€å¤§æ¨¡å‹

### 1. **æ–‡æ¡£ä¸“ç”¨æ¨¡å‹**
- **KOSMOS-2.5**: å¾®è½¯å¼€å‘çš„å¤šæ¨¡æ€è¯†è¯»æ¨¡å‹ï¼Œä¸“ä¸ºæ–‡æœ¬å¯†é›†å‹å›¾åƒè®¾è®¡ï¼Œèƒ½ç”Ÿæˆå¸¦ç©ºé—´åæ ‡çš„æ–‡æœ¬å—ï¼Œè¾“å‡ºMarkdownæ ¼å¼
- **LayoutLMç³»åˆ—** (LayoutLM/v2/v3): ä¸“é—¨ç”¨äºæ–‡æ¡£AIçš„é¢„è®­ç»ƒæ¨¡å‹ï¼Œé‡‡ç”¨ç»Ÿä¸€çš„æ–‡æœ¬å’Œå›¾åƒæ©ç ç­–ç•¥
- **mPLUG-DocOwl**: åŸºäºmPLUG-Owlçš„æ–‡æ¡£ç†è§£æ¨¡å‹ï¼Œæ”¯æŒOCR-freeçš„æ–‡æ¡£å¤„ç†
- **DocLLM**: é¢å‘å¤šæ¨¡æ€æ–‡æ¡£ç†è§£çš„å¸ƒå±€æ„ŸçŸ¥ç”Ÿæˆå¼è¯­è¨€æ¨¡å‹

### 2. **é€šç”¨å¤šæ¨¡æ€æ¨¡å‹**
- **Qwen-VLç³»åˆ—**: é˜¿é‡Œå·´å·´å¼€æºçš„è§†è§‰-è¯­è¨€æ¨¡å‹ï¼Œæ”¯æŒå›¾ç‰‡ç†è§£å’Œæ–‡æœ¬ç”Ÿæˆ
- **LLaVAç³»åˆ—**: å¤§è§„æ¨¡è¯­è¨€å’Œè§†è§‰åŠ©æ‰‹ï¼Œå¼€æºä¸”æ€§èƒ½ä¼˜ç§€
- **InternVLç³»åˆ—**: å•†æ±¤å’Œä¸Šæµ·AIå®éªŒå®¤å¼€æºçš„å¤šæ¨¡æ€æ¨¡å‹
- **MiniCPM-Vç³»åˆ—**: é¢å£æ™ºèƒ½å¼€æºçš„è½»é‡çº§å¤šæ¨¡æ€æ¨¡å‹
- **CogVLM/CogAgent**: æ™ºè°±AIå¼€æºçš„è§†è§‰-è¯­è¨€æ¨¡å‹

### 3. **å•†ç”¨APIæœåŠ¡**
- **é€šä¹‰åƒé—®-VL**: é˜¿é‡Œäº‘æä¾›APIæœåŠ¡
- **æ–‡å¿ƒä¸€è¨€**: ç™¾åº¦æä¾›å¤šæ¨¡æ€API
- **è®¯é£æ˜Ÿç«**: ç§‘å¤§è®¯é£çš„å¤šæ¨¡æ€æœåŠ¡
- **å­—èŠ‚è±†åŒ…**: å­—èŠ‚è·³åŠ¨çš„å¤šæ¨¡æ€API

## æ‚¨çš„æŠ€æœ¯æ–¹æ¡ˆåˆ†æ

æ‚¨æå‡ºçš„"PDFè½¬æ–‡æœ¬+å›¾ç‰‡"æ–¹æ¡ˆéå¸¸æœ‰ä»·å€¼ï¼[[memory:8270598]] è¿™ç§æ–¹æ¡ˆçš„ä¼˜åŠ¿ï¼š

1. **æ–‡æœ¬æä¾›å‡†ç¡®å†…å®¹**: é¿å…OCRè¯†åˆ«é”™è¯¯
2. **å›¾ç‰‡ä¿ç•™å¸ƒå±€ä¿¡æ¯**: ä¿æŒåŸå§‹æ’ç‰ˆç»“æ„
3. **äº’è¡¥æ€§å¼º**: æ–‡æœ¬+è§†è§‰ä¿¡æ¯ç»“åˆ
4. **é€‚ç”¨æ€§å¹¿**: æ”¯æŒæ›´å¤šåªèƒ½å¤„ç†å›¾ç‰‡+æ–‡æœ¬çš„æ¨¡å‹

## å®ç°å»ºè®®

åŸºäºæ‚¨å½“å‰çš„PDFConverté¡¹ç›®ï¼Œå¯ä»¥è¿™æ ·æ‰©å±•ï¼š

åŸºäºæ‚¨çš„éœ€æ±‚å’Œç°æœ‰ä»£ç ï¼Œæˆ‘å»ºè®®æ‰©å±•å½“å‰çš„PDFConverté¡¹ç›®æ¥æ”¯æŒå¤šæ¨¡æ€å¤§æ¨¡å‹ã€‚å¯ä»¥æ·»åŠ ä¸€ä¸ªæ–°çš„æ¨¡å—æ¥å¤„ç†"æ–‡æœ¬+å›¾ç‰‡"çš„æ–¹æ¡ˆï¼š

```python:src/core/multimodal_converter.py
"""
å¤šæ¨¡æ€å¤§æ¨¡å‹è½¬æ¢å™¨
æ”¯æŒå°†PDFè½¬æ¢ä¸ºæ–‡æœ¬+å›¾ç‰‡ï¼Œç„¶åè°ƒç”¨å¤šæ¨¡æ€å¤§æ¨¡å‹ç”ŸæˆTypst
"""

from __future__ import annotations
from pathlib import Path
from typing import List, Dict, Any, Optional
import json
import base64
from dataclasses import dataclass

@dataclass
class MultimodalInput:
    """å¤šæ¨¡æ€è¾“å…¥æ•°æ®"""
    text_content: str  # Markdownæ ¼å¼çš„æ–‡æœ¬å†…å®¹
    page_images: List[Dict[str, Any]]  # é¡µé¢å›¾ç‰‡åˆ—è¡¨
    layout_info: Dict[str, Any]  # å¸ƒå±€ä¿¡æ¯

class MultimodalConverter:
    """å¤šæ¨¡æ€è½¬æ¢å™¨åŸºç±»"""
    
    def __init__(self, model_name: str, api_config: Dict[str, Any]):
        self.model_name = model_name
        self.api_config = api_config
    
    def prepare_input(self, pdf_path: Path) -> MultimodalInput:
        """å‡†å¤‡å¤šæ¨¡æ€è¾“å…¥æ•°æ®"""
        # æå–æ–‡æœ¬å†…å®¹ï¼ˆMarkdownæ ¼å¼ï¼‰
        text_content = self._extract_text_as_markdown(pdf_path)
        
        # å°†æ¯é¡µè½¬æ¢ä¸ºå›¾ç‰‡
        page_images = self._pdf_pages_to_images(pdf_path)
        
        # æå–å¸ƒå±€ä¿¡æ¯
        layout_info = self._extract_layout_info(pdf_path)
        
        return MultimodalInput(
            text_content=text_content,
            page_images=page_images,
            layout_info=layout_info
        )
    
    def convert_to_typst(self, multimodal_input: MultimodalInput) -> str:
        """è°ƒç”¨å¤šæ¨¡æ€å¤§æ¨¡å‹ç”ŸæˆTypst"""
        raise NotImplementedError
    
    def _extract_text_as_markdown(self, pdf_path: Path) -> str:
        """å°†PDFæ–‡æœ¬æå–ä¸ºMarkdownæ ¼å¼"""
        # ä½¿ç”¨ç°æœ‰çš„PDFè§£æå™¨
        # ... existing code ...
        
    def _pdf_pages_to_images(self, pdf_path: Path) -> List[Dict[str, Any]]:
        """å°†PDFé¡µé¢è½¬æ¢ä¸ºå›¾ç‰‡"""
        # ä½¿ç”¨PyMuPDFå°†æ¯é¡µè½¬æ¢ä¸ºé«˜åˆ†è¾¨ç‡å›¾ç‰‡
        # ... existing code ...
        
    def _extract_layout_info(self, pdf_path: Path) -> Dict[str, Any]:
        """æå–å¸ƒå±€ä¿¡æ¯"""
        # æå–é¡µé¢å°ºå¯¸ã€å…ƒç´ ä½ç½®ç­‰ä¿¡æ¯
        # ... existing code ...

class QwenVLConverter(MultimodalConverter):
    """é€šä¹‰åƒé—®-VLè½¬æ¢å™¨"""
    
    def convert_to_typst(self, multimodal_input: MultimodalInput) -> str:
        # æ„å»ºæç¤ºè¯
        prompt = self._build_prompt(multimodal_input)
        
        # è°ƒç”¨é€šä¹‰åƒé—®-VL API
        # ... implementation ...

class LLaVAConverter(MultimodalConverter):
    """LLaVAè½¬æ¢å™¨"""
    
    def convert_to_typst(self, multimodal_input: MultimodalInput) -> str:
        # æœ¬åœ°éƒ¨ç½²çš„LLaVAè°ƒç”¨
        # ... implementation ...

class InternVLConverter(MultimodalConverter):
    """InternVLè½¬æ¢å™¨"""
    
    def convert_to_typst(self, multimodal_input: MultimodalInput) -> str:
        # InternVL APIè°ƒç”¨
        # ... implementation ...
```

## æ¨èçš„å®ç°è·¯å¾„

1. **ä¼˜å…ˆé€‰æ‹©çš„æ¨¡å‹**:
   - **KOSMOS-2.5**: ä¸“é—¨ä¸ºæ–‡æ¡£è®¾è®¡ï¼Œè¾“å‡ºMarkdownæ ¼å¼
   - **Qwen-VL**: é˜¿é‡Œäº‘APIç¨³å®šï¼Œä¸­æ–‡æ”¯æŒå¥½
   - **InternVL**: å¼€æºä¸”æ€§èƒ½ä¼˜ç§€ï¼Œå¯æœ¬åœ°éƒ¨ç½²

2. **æŠ€æœ¯æ ˆå»ºè®®**:
   - ä½¿ç”¨æ‚¨ç°æœ‰çš„PyMuPDFå°†PDFé¡µé¢è½¬ä¸ºé«˜è´¨é‡å›¾ç‰‡
   - ç”¨pdfplumberæå–çº¯æ–‡æœ¬å¹¶è½¬æ¢ä¸ºMarkdown
   - ç»“åˆä¸¤è€…ä¿¡æ¯è°ƒç”¨å¤šæ¨¡æ€å¤§æ¨¡å‹

3. **æç¤ºè¯è®¾è®¡**:
```text
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ–‡æ¡£è½¬æ¢ä¸“å®¶ã€‚æˆ‘æä¾›ç»™ä½ ï¼š
1. PDFæ–‡æ¡£çš„æ–‡æœ¬å†…å®¹ï¼ˆMarkdownæ ¼å¼ï¼‰
2. PDFæ–‡æ¡£çš„é¡µé¢æˆªå›¾
3. é¡µé¢å¸ƒå±€ä¿¡æ¯

è¯·æ ¹æ®è¿™äº›ä¿¡æ¯ï¼Œç”Ÿæˆå‡†ç¡®çš„Typstæ ¼å¼æ–‡æ¡£ï¼Œè¦æ±‚ï¼š
- ä¿æŒåŸæ–‡æ¡£çš„æ’ç‰ˆå¸ƒå±€
- æ­£ç¡®å¤„ç†å›¾æ–‡æ··æ’
- å‡†ç¡®è½¬æ¢è¡¨æ ¼ç»“æ„
- ä¿æŒæ•°å­¦å…¬å¼æ ¼å¼
```

è¿™ç§æ–¹æ¡ˆç»“åˆäº†æ–‡æœ¬çš„å‡†ç¡®æ€§å’Œå›¾ç‰‡çš„å¸ƒå±€ä¿¡æ¯ï¼Œåº”è¯¥èƒ½æ˜¾è‘—æå‡è½¬æ¢è´¨é‡ã€‚æ‚¨è§‰å¾—è¿™ä¸ªæ–¹å‘å¦‚ä½•ï¼Ÿéœ€è¦æˆ‘è¯¦ç»†å±•å¼€æŸä¸ªéƒ¨åˆ†çš„å®ç°å—ï¼Ÿ

```python
"""
å¤šæ¨¡æ€å¤§æ¨¡å‹è½¬æ¢å™¨
æ”¯æŒå°†PDFè½¬æ¢ä¸ºæ–‡æœ¬+å›¾ç‰‡ï¼Œç„¶åè°ƒç”¨å¤šæ¨¡æ€å¤§æ¨¡å‹ç”ŸæˆTypst
"""

from __future__ import annotations
from pathlib import Path
from typing import List, Dict, Any, Optional
import json
import base64
from dataclasses import dataclass

@dataclass
class MultimodalInput:
    """å¤šæ¨¡æ€è¾“å…¥æ•°æ®"""
    text_content: str  # Markdownæ ¼å¼çš„æ–‡æœ¬å†…å®¹
    page_images: List[Dict[str, Any]]  # é¡µé¢å›¾ç‰‡åˆ—è¡¨
    layout_info: Dict[str, Any]  # å¸ƒå±€ä¿¡æ¯

class MultimodalConverter:
    """å¤šæ¨¡æ€è½¬æ¢å™¨åŸºç±»"""
    
    def __init__(self, model_name: str, api_config: Dict[str, Any]):
        self.model_name = model_name
        self.api_config = api_config
    
    def prepare_input(self, pdf_path: Path) -> MultimodalInput:
        """å‡†å¤‡å¤šæ¨¡æ€è¾“å…¥æ•°æ®"""
        # æå–æ–‡æœ¬å†…å®¹ï¼ˆMarkdownæ ¼å¼ï¼‰
        text_content = self._extract_text_as_markdown(pdf_path)
        
        # å°†æ¯é¡µè½¬æ¢ä¸ºå›¾ç‰‡
        page_images = self._pdf_pages_to_images(pdf_path)
        
        # æå–å¸ƒå±€ä¿¡æ¯
        layout_info = self._extract_layout_info(pdf_path)
        
        return MultimodalInput(
            text_content=text_content,
            page_images=page_images,
            layout_info=layout_info
        )
    
    def convert_to_typst(self, multimodal_input: MultimodalInput) -> str:
        """è°ƒç”¨å¤šæ¨¡æ€å¤§æ¨¡å‹ç”ŸæˆTypst"""
        raise NotImplementedError
    
    def _extract_text_as_markdown(self, pdf_path: Path) -> str:
        """å°†PDFæ–‡æœ¬æå–ä¸ºMarkdownæ ¼å¼"""
        # ä½¿ç”¨ç°æœ‰çš„PDFè§£æå™¨
        # ... existing code ...
        
    def _pdf_pages_to_images(self, pdf_path: Path) -> List[Dict[str, Any]]:
        """å°†PDFé¡µé¢è½¬æ¢ä¸ºå›¾ç‰‡"""
        # ä½¿ç”¨PyMuPDFå°†æ¯é¡µè½¬æ¢ä¸ºé«˜åˆ†è¾¨ç‡å›¾ç‰‡
        # ... existing code ...
        
    def _extract_layout_info(self, pdf_path: Path) -> Dict[str, Any]:
        """æå–å¸ƒå±€ä¿¡æ¯"""
        # æå–é¡µé¢å°ºå¯¸ã€å…ƒç´ ä½ç½®ç­‰ä¿¡æ¯
        # ... existing code ...

class QwenVLConverter(MultimodalConverter):
    """é€šä¹‰åƒé—®-VLè½¬æ¢å™¨"""
    
    def convert_to_typst(self, multimodal_input: MultimodalInput) -> str:
        # æ„å»ºæç¤ºè¯
        prompt = self._build_prompt(multimodal_input)
        
        # è°ƒç”¨é€šä¹‰åƒé—®-VL API
        # ... implementation ...

class LLaVAConverter(MultimodalConverter):
    """LLaVAè½¬æ¢å™¨"""
    
    def convert_to_typst(self, multimodal_input: MultimodalInput) -> str:
        # æœ¬åœ°éƒ¨ç½²çš„LLaVAè°ƒç”¨
        # ... implementation ...

class InternVLConverter(MultimodalConverter):
    """InternVLè½¬æ¢å™¨"""
    
    def convert_to_typst(self, multimodal_input: MultimodalInput) -> str:
        # InternVL APIè°ƒç”¨
        # ... implementation ...
```

```plaintext
ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ–‡æ¡£è½¬æ¢ä¸“å®¶ã€‚æˆ‘æä¾›ç»™ä½ ï¼š
1. PDFæ–‡æ¡£çš„æ–‡æœ¬å†…å®¹ï¼ˆMarkdownæ ¼å¼ï¼‰
2. PDFæ–‡æ¡£çš„é¡µé¢æˆªå›¾
3. é¡µé¢å¸ƒå±€ä¿¡æ¯

è¯·æ ¹æ®è¿™äº›ä¿¡æ¯ï¼Œç”Ÿæˆå‡†ç¡®çš„Typstæ ¼å¼æ–‡æ¡£ï¼Œè¦æ±‚ï¼š
- ä¿æŒåŸæ–‡æ¡£çš„æ’ç‰ˆå¸ƒå±€
- æ­£ç¡®å¤„ç†å›¾æ–‡æ··æ’
- å‡†ç¡®è½¬æ¢è¡¨æ ¼ç»“æ„
- ä¿æŒæ•°å­¦å…¬å¼æ ¼å¼
```

---

**User**

ä¸Šé¢æåˆ°çš„å„å¼€æºå¤§æ¨¡å‹éœ€è¦è‡ªå·±å®‰è£…éƒ¨ç½²å—ï¼Ÿå¦‚æœéœ€è¦è‡ªå·±å®‰è£…éƒ¨ç½²ï¼Œå¯¹æœåŠ¡å™¨æ€§èƒ½è¦æ±‚æ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿå¦‚æœæœ‰å¯ç”¨çš„æœåŠ¡APIï¼Œä½¿ç”¨çš„æ³¨å†Œè®¤è¯è¦æ±‚æœ‰å“ªäº›ï¼Œè´¹ç”¨åˆ†åˆ«æ˜¯å¤šå°‘ï¼Ÿ

---

**Cursor**

è®©æˆ‘ä¸ºæ‚¨è¯¦ç»†è°ƒç ”å„ä¸ªå¼€æºå¤§æ¨¡å‹çš„éƒ¨ç½²è¦æ±‚å’ŒAPIæœåŠ¡æƒ…å†µï¼š

æ ¹æ®æˆ‘çš„è°ƒç ”ï¼Œè®©æˆ‘ä¸ºæ‚¨è¯¦ç»†æ•´ç†å„å¼€æºå¤§æ¨¡å‹çš„éƒ¨ç½²è¦æ±‚å’ŒAPIæœåŠ¡æƒ…å†µï¼š

## ğŸ–¥ï¸ æœ¬åœ°éƒ¨ç½²è¦æ±‚

### **è½»é‡çº§æ¨¡å‹ï¼ˆæ¨èå…¥é—¨ï¼‰**

**MiniCPM-Vç³»åˆ—**
- **GPU**: NVIDIA RTX 3060/4060 (8GBæ˜¾å­˜) 
- **å†…å­˜**: 16GB RAM
- **å­˜å‚¨**: 50GB
- **ä¼˜åŠ¿**: ç¡¬ä»¶è¦æ±‚æœ€ä½ï¼Œé€‚åˆä¸ªäººå¼€å‘

**Qwen-VL-Chat (7B)**
- **GPU**: NVIDIA RTX 3090 (24GBæ˜¾å­˜)
- **å†…å­˜**: 32GB RAM  
- **å­˜å‚¨**: 100GB
- **ä¼˜åŠ¿**: ä¸­æ–‡æ”¯æŒä¼˜ç§€ï¼Œæ€§èƒ½ä¸é”™

### **ä¸­ç­‰è§„æ¨¡æ¨¡å‹**

**LLaVA-1.5 (13B)**
- **GPU**: NVIDIA RTX 4090 (24GBæ˜¾å­˜) æˆ– A100 (40GB)
- **å†…å­˜**: 64GB RAM
- **å­˜å‚¨**: 150GB
- **ä¼˜åŠ¿**: å¼€æºç”Ÿæ€å®Œå–„ï¼Œç¤¾åŒºæ´»è·ƒ

**InternVL-Chat (26B)**
- **GPU**: 2Ã—NVIDIA RTX 4090 æˆ– 1Ã—A100 (80GB)
- **å†…å­˜**: 128GB RAM
- **å­˜å‚¨**: 200GB
- **ä¼˜åŠ¿**: æ€§èƒ½æ¥è¿‘å•†ç”¨æ¨¡å‹

### **å¤§è§„æ¨¡æ¨¡å‹**

**CogVLM2 (19B)**
- **GPU**: NVIDIA A100 (80GB) æˆ– 2Ã—RTX 4090
- **å†…å­˜**: 128GB RAM
- **å­˜å‚¨**: 300GB
- **ä¼˜åŠ¿**: æ™ºè°±AIå‡ºå“ï¼Œä¸­æ–‡è¡¨ç°ä¼˜ç§€

**KOSMOS-2.5**
- **GPU**: NVIDIA H100 (80GB) æ¨è
- **å†…å­˜**: 256GB RAM
- **å­˜å‚¨**: 500GB
- **ä¼˜åŠ¿**: ä¸“ä¸ºæ–‡æ¡£ç†è§£è®¾è®¡

## ğŸ’° APIæœåŠ¡è´¹ç”¨å¯¹æ¯”

### **å›½å†…å‚å•†ï¼ˆæ€§ä»·æ¯”é«˜ï¼Œæ¨èï¼‰**

| æœåŠ¡å•† | æ¨¡å‹ | è¾“å…¥ä»·æ ¼ | è¾“å‡ºä»·æ ¼ | å…è´¹é¢åº¦ | è®¤è¯è¦æ±‚ |
|--------|------|----------|----------|----------|----------|
| **é˜¿é‡Œäº‘** | é€šä¹‰åƒé—®-VL | Â¥0.0005/åƒtoken | Â¥0.002/åƒtoken | 100ä¸‡token | å®åè®¤è¯ |
| **ç™¾åº¦** | æ–‡å¿ƒä¸€è¨€4.0 | **å…è´¹** | **å…è´¹** | æ— é™åˆ¶ | å®åè®¤è¯ |
| **å­—èŠ‚è·³åŠ¨** | è±†åŒ…-vision | Â¥0.0008/åƒtoken | Â¥0.003/åƒtoken | 50ä¸‡token | å®åè®¤è¯ |
| **ç§‘å¤§è®¯é£** | æ˜Ÿç«4.0 | Â¥0.002/åƒtoken | Â¥0.008/åƒtoken | 20ä¸‡token | å®åè®¤è¯ |

### **å›½å¤–å‚å•†**

| æœåŠ¡å•† | æ¨¡å‹ | è¾“å…¥ä»·æ ¼ | è¾“å‡ºä»·æ ¼ | å…è´¹é¢åº¦ | è®¤è¯è¦æ±‚ |
|--------|------|----------|----------|----------|----------|
| **OpenAI** | GPT-4V | Â¥0.01/åƒtoken | Â¥0.03/åƒtoken | $5è¯•ç”¨ | ä¿¡ç”¨å¡éªŒè¯ |
| **Anthropic** | Claude-3 | Â¥0.003/åƒtoken | Â¥0.015/åƒtoken | æœ‰é™å…è´¹ | ä¿¡ç”¨å¡éªŒè¯ |
| **Google** | Gemini Pro Vision | Â¥0.0025/åƒtoken | Â¥0.0075/åƒtoken | æœ‰é™å…è´¹ | Googleè´¦æˆ· |

### **å¼€æºAPIæœåŠ¡å¹³å°**

**Hugging Face Inference API**
- **è´¹ç”¨**: $0.06/å°æ—¶ (æŒ‰éœ€ä»˜è´¹)
- **æ”¯æŒæ¨¡å‹**: LLaVAã€InternVLã€MiniCPM-Vç­‰
- **è®¤è¯**: ä¿¡ç”¨å¡éªŒè¯
- **ä¼˜åŠ¿**: æ— éœ€æœ¬åœ°éƒ¨ç½²ï¼Œæ”¯æŒå¤šç§å¼€æºæ¨¡å‹

**Together AI**
- **è´¹ç”¨**: $0.2-0.8/ç™¾ä¸‡token (æŒ‰æ¨¡å‹ä¸åŒ)
- **æ”¯æŒæ¨¡å‹**: LLaVAã€CogVLMç­‰å¼€æºæ¨¡å‹
- **è®¤è¯**: é‚®ç®±æ³¨å†Œ + ä¿¡ç”¨å¡
- **ä¼˜åŠ¿**: ä¸“é—¨æä¾›å¼€æºæ¨¡å‹API

## ğŸ“‹ æ¨èæ–¹æ¡ˆ

### **é¢„ç®—æœ‰é™ï¼ˆæœˆè´¹ç”¨<100å…ƒï¼‰**
1. **ç™¾åº¦æ–‡å¿ƒä¸€è¨€** - å®Œå…¨å…è´¹ï¼ŒåŠŸèƒ½å¼ºå¤§
2. **é˜¿é‡Œäº‘é€šä¹‰åƒé—®** - æä½ä»·æ ¼ï¼Œ100ä¸‡tokenå…è´¹é¢åº¦
3. **æœ¬åœ°éƒ¨ç½²MiniCPM-V** - ä¸€æ¬¡æ€§ç¡¬ä»¶æŠ•å…¥

### **ä¸­ç­‰é¢„ç®—ï¼ˆæœˆè´¹ç”¨100-500å…ƒï¼‰**
1. **å­—èŠ‚è±†åŒ… + é˜¿é‡Œäº‘é€šä¹‰åƒé—®** - ç»„åˆä½¿ç”¨ï¼Œæ€§ä»·æ¯”é«˜
2. **æœ¬åœ°éƒ¨ç½²Qwen-VL-Chat** - æ›´å¥½çš„éšç§ä¿æŠ¤
3. **Hugging Face API** - çµæ´»é€‰æ‹©ä¸åŒå¼€æºæ¨¡å‹

### **é«˜æ€§èƒ½éœ€æ±‚ï¼ˆæœˆè´¹ç”¨>500å…ƒï¼‰**
1. **Claude-3 + å›½å†…æ¨¡å‹ç»„åˆ** - æœ€ä½³æ€§èƒ½
2. **æœ¬åœ°éƒ¨ç½²InternVL/CogVLM2** - å®Œå…¨è‡ªä¸»æ§åˆ¶
3. **ä¼ä¸šçº§APIæœåŠ¡** - ä¸“ä¸šæŠ€æœ¯æ”¯æŒ

## ğŸ”§ å¿«é€Ÿå¼€å§‹å»ºè®®

å¯¹äºæ‚¨çš„PDFConverté¡¹ç›®ï¼Œæˆ‘å»ºè®®ï¼š

1. **å…ˆè¯•ç”¨å…è´¹API**: ç™¾åº¦æ–‡å¿ƒä¸€è¨€ + é˜¿é‡Œäº‘é€šä¹‰åƒé—®å…è´¹é¢åº¦
2. **è¯„ä¼°æ•ˆæœåé€‰æ‹©**: æ ¹æ®è½¬æ¢è´¨é‡é€‰æ‹©æœ€é€‚åˆçš„æœåŠ¡
3. **è€ƒè™‘æ··åˆæ–¹æ¡ˆ**: ä¸åŒç±»å‹æ–‡æ¡£ä½¿ç”¨ä¸åŒæ¨¡å‹ï¼Œä¼˜åŒ–æˆæœ¬å’Œæ•ˆæœ

éœ€è¦æˆ‘å¸®æ‚¨å®ç°å…·ä½“çš„APIé›†æˆä»£ç å—ï¼Ÿ

---

**User**

æˆ‘è¿˜è€ƒè™‘ï¼Œæ˜¯å¦å¯ä»¥å°†pdfè½¬æ¢ä¸ºtypstçš„åŠŸèƒ½å¼€å‘æˆä¸€ä¸ªMCPæœåŠ¡æˆ–å…¶ä»–ä»€ä¹ˆæ’ä»¶ï¼Œç”±ç”¨æˆ·çš„Agenté…ç½®ä¸Šè¿™ä¸ªæœåŠ¡å°±å¯ä»¥ä½¿ç”¨äº†

---

**Cursor**

è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„æƒ³æ³•ï¼å°†PDFè½¬TypståŠŸèƒ½å¼€å‘æˆMCPæœåŠ¡æˆ–å…¶ä»–æ’ä»¶å½¢å¼ï¼Œå¯ä»¥è®©æ›´å¤šç”¨æˆ·æ–¹ä¾¿åœ°ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½ã€‚è®©æˆ‘ä¸ºæ‚¨åˆ†æå‡ ç§å¯è¡Œçš„æ–¹æ¡ˆï¼š

æ‚¨çš„æƒ³æ³•éå¸¸æ£’ï¼å°†PDFè½¬TypståŠŸèƒ½å¼€å‘æˆå„ç§æ’ä»¶å½¢å¼ï¼Œå¯ä»¥å¤§å¤§æå‡å…¶ä½¿ç”¨ä¾¿åˆ©æ€§å’Œè¦†ç›–é¢ã€‚è®©æˆ‘ä¸ºæ‚¨åˆ†æå‡ ç§å¯è¡Œçš„å®ç°æ–¹æ¡ˆï¼š

## ğŸ”Œ æ’ä»¶å¼€å‘æ–¹æ¡ˆå¯¹æ¯”

### **1. MCP (Model Context Protocol) æœåŠ¡** â­â­â­â­â­

**é€‚ç”¨åœºæ™¯**: Claude Desktopã€Cursorã€æ”¯æŒMCPçš„AIåº”ç”¨

**ä¼˜åŠ¿**:
- Anthropicå®˜æ–¹æ¨åŠ¨çš„å¼€æ”¾æ ‡å‡†
- ä¸Claudeç­‰LLMæ— ç¼é›†æˆ
- æ ‡å‡†åŒ–æ¥å£ï¼Œæ˜“äºç»´æŠ¤

**å¼€å‘ç¤ºä¾‹**:

åŸºäºæ‚¨ç°æœ‰çš„ä»£ç ï¼Œæˆ‘å¯ä»¥è®¾è®¡ä¸€ä¸ªMCPæœåŠ¡å™¨ï¼š

```python:mcp_server/pdf_to_typst_server.py
"""
PDFè½¬Typst MCPæœåŠ¡å™¨
æ”¯æŒClaude Desktopã€Cursorç­‰MCPå®¢æˆ·ç«¯
"""

import asyncio
import json
import logging
from pathlib import Path
from typing import Any, Dict, List, Optional

# MCPç›¸å…³å¯¼å…¥
from mcp import ClientSession, StdioServerSession
from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.types import (
    CallToolRequest,
    CallToolResult,
    ListToolsRequest, 
    ListToolsResult,
    Tool,
    TextContent
)

# å¯¼å…¥æ‚¨ç°æœ‰çš„PDFè½¬æ¢åŠŸèƒ½
from src.core.pdf_parser import HybridPDFParser
from src.core.typst_generator import TypstGenerator
from src.core.pipeline import ConversionPipeline

logger = logging.getLogger(__name__)

class PDFToTypstMCPServer:
    """PDFè½¬Typst MCPæœåŠ¡å™¨"""
    
    def __init__(self):
        self.server = Server("pdf-to-typst")
        self.pipeline = ConversionPipeline()
        self._setup_tools()
    
    def _setup_tools(self):
        """è®¾ç½®MCPå·¥å…·"""
        
        @self.server.list_tools()
        async def handle_list_tools() -> ListToolsResult:
            return ListToolsResult(
                tools=[
                    Tool(
                        name="convert_pdf_to_typst",
                        description="å°†PDFæ–‡ä»¶è½¬æ¢ä¸ºTypstæ ¼å¼",
                        inputSchema={
                            "type": "object",
                            "properties": {
                                "pdf_path": {
                                    "type": "string",
                                    "description": "PDFæ–‡ä»¶è·¯å¾„"
                                },
                                "output_path": {
                                    "type": "string", 
                                    "description": "è¾“å‡ºTypstæ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰"
                                },
                                "use_multimodal": {
                                    "type": "boolean",
                                    "description": "æ˜¯å¦ä½¿ç”¨å¤šæ¨¡æ€å¤§æ¨¡å‹å¢å¼ºè½¬æ¢ï¼ˆå¯é€‰ï¼‰"
                                }
                            },
                            "required": ["pdf_path"]
                        }
                    ),
                    Tool(
                        name="analyze_pdf_structure",
                        description="åˆ†æPDFæ–‡æ¡£ç»“æ„ï¼Œè¿”å›é¡µé¢ä¿¡æ¯å’Œå…ƒç´ ç»Ÿè®¡",
                        inputSchema={
                            "type": "object", 
                            "properties": {
                                "pdf_path": {
                                    "type": "string",
                                    "description": "PDFæ–‡ä»¶è·¯å¾„"
                                }
                            },
                            "required": ["pdf_path"]
                        }
                    ),
                    Tool(
                        name="preview_typst_output",
                        description="é¢„è§ˆPDFè½¬æ¢åçš„Typstä»£ç ç‰‡æ®µ",
                        inputSchema={
                            "type": "object",
                            "properties": {
                                "pdf_path": {
                                    "type": "string", 
                                    "description": "PDFæ–‡ä»¶è·¯å¾„"
                                },
                                "page_range": {
                                    "type": "string",
                                    "description": "é¡µé¢èŒƒå›´ï¼Œå¦‚'1-3'æˆ–'1,3,5'"
                                }
                            },
                            "required": ["pdf_path"]
                        }
                    )
                ]
            )
        
        @self.server.call_tool()
        async def handle_call_tool(
            name: str, arguments: Dict[str, Any]
        ) -> CallToolResult:
            try:
                if name == "convert_pdf_to_typst":
                    return await self._convert_pdf_to_typst(arguments)
                elif name == "analyze_pdf_structure":
                    return await self._analyze_pdf_structure(arguments)
                elif name == "preview_typst_output":
                    return await self._preview_typst_output(arguments)
                else:
                    raise ValueError(f"æœªçŸ¥å·¥å…·: {name}")
            
            except Exception as e:
                logger.error(f"å·¥å…·è°ƒç”¨å¤±è´¥ {name}: {e}")
                return CallToolResult(
                    content=[TextContent(
                        type="text",
                        text=f"è½¬æ¢å¤±è´¥: {str(e)}"
                    )],
                    isError=True
                )
    
    async def _convert_pdf_to_typst(self, args: Dict[str, Any]) -> CallToolResult:
        """æ‰§è¡ŒPDFåˆ°Typstè½¬æ¢"""
        pdf_path = Path(args["pdf_path"])
        output_path = args.get("output_path")
        use_multimodal = args.get("use_multimodal", False)
        
        if not pdf_path.exists():
            raise FileNotFoundError(f"PDFæ–‡ä»¶ä¸å­˜åœ¨: {pdf_path}")
        
        # æ‰§è¡Œè½¬æ¢
        result = await asyncio.to_thread(
            self.pipeline.convert,
            pdf_path=pdf_path,
            output_path=output_path,
            use_multimodal=use_multimodal
        )
        
        return CallToolResult(
            content=[TextContent(
                type="text", 
                text=f"è½¬æ¢å®Œæˆï¼\nè¾“å‡ºæ–‡ä»¶: {result.output_path}\n"
                     f"å¤„ç†é¡µæ•°: {result.pages_processed}\n"
                     f"è½¬æ¢æ—¶é—´: {result.conversion_time:.2f}ç§’"
            )]
        )
    
    async def _analyze_pdf_structure(self, args: Dict[str, Any]) -> CallToolResult:
        """åˆ†æPDFç»“æ„"""
        pdf_path = Path(args["pdf_path"])
        
        parser = HybridPDFParser()
        metadata = parser.extract_metadata(pdf_path)
        pages_info = parser.get_page_info(pdf_path)
        
        analysis = {
            "æ–‡æ¡£ä¿¡æ¯": {
                "æ ‡é¢˜": metadata.title or "æœªçŸ¥",
                "ä½œè€…": metadata.author or "æœªçŸ¥", 
                "é¡µæ•°": metadata.pages
            },
            "é¡µé¢ä¿¡æ¯": [
                {
                    "é¡µç ": page.number,
                    "å°ºå¯¸": f"{page.width:.1f}x{page.height:.1f}",
                    "æ—‹è½¬": page.rotation
                }
                for page in pages_info[:5]  # åªæ˜¾ç¤ºå‰5é¡µ
            ]
        }
        
        return CallToolResult(
            content=[TextContent(
                type="text",
                text=f"PDFç»“æ„åˆ†æ:\n{json.dumps(analysis, ensure_ascii=False, indent=2)}"
            )]
        )
    
    async def _preview_typst_output(self, args: Dict[str, Any]) -> CallToolResult:
        """é¢„è§ˆTypstè¾“å‡º"""
        pdf_path = Path(args["pdf_path"])
        page_range = args.get("page_range", "1")
        
        # è§£æé¡µé¢èŒƒå›´
        pages = self._parse_page_range(page_range)
        
        # æå–æŒ‡å®šé¡µé¢å†…å®¹å¹¶ç”ŸæˆTypsté¢„è§ˆ
        preview = await asyncio.to_thread(
            self.pipeline.generate_preview,
            pdf_path=pdf_path,
            pages=pages
        )
        
        return CallToolResult(
            content=[TextContent(
                type="text",
                text=f"Typstä»£ç é¢„è§ˆ (é¡µé¢ {page_range}):\n\n```typst\n{preview}\n```"
            )]
        )
    
    def _parse_page_range(self, page_range: str) -> List[int]:
        """è§£æé¡µé¢èŒƒå›´å­—ç¬¦ä¸²"""
        pages = []
        for part in page_range.split(','):
            if '-' in part:
                start, end = map(int, part.split('-'))
                pages.extend(range(start, end + 1))
            else:
                pages.append(int(part))
        return pages
    
    async def run(self):
        """è¿è¡ŒMCPæœåŠ¡å™¨"""
        async with StdioServerSession() as session:
            await self.server.run(session)

async def main():
    """ä¸»å‡½æ•°"""
    server = PDFToTypstMCPServer()
    await server.run()

if __name__ == "__main__":
    asyncio.run(main())
```

### **2. OpenAI Function/Tool** â­â­â­â­

**é€‚ç”¨åœºæ™¯**: ChatGPTã€GPT-4ã€æ”¯æŒFunction Callingçš„åº”ç”¨

```python:plugins/openai_function.py
"""
OpenAI Function Calling æ’ä»¶
"""

import json
from typing import Dict, Any
from pathlib import Path

# OpenAI Function å®šä¹‰
PDF_TO_TYPST_FUNCTION = {
    "name": "convert_pdf_to_typst",
    "description": "å°†PDFæ–‡ä»¶è½¬æ¢ä¸ºTypstæ ¼å¼ï¼Œæ”¯æŒå›¾æ–‡æ··æ’ã€è¡¨æ ¼å’Œæ•°å­¦å…¬å¼",
    "parameters": {
        "type": "object",
        "properties": {
            "pdf_path": {
                "type": "string",
                "description": "PDFæ–‡ä»¶çš„å®Œæ•´è·¯å¾„"
            },
            "output_directory": {
                "type": "string", 
                "description": "è¾“å‡ºç›®å½•è·¯å¾„ï¼ˆå¯é€‰ï¼‰"
            },
            "conversion_options": {
                "type": "object",
                "properties": {
                    "use_multimodal": {"type": "boolean", "description": "æ˜¯å¦ä½¿ç”¨å¤šæ¨¡æ€AIå¢å¼º"},
                    "preserve_images": {"type": "boolean", "description": "æ˜¯å¦ä¿ç•™åŸå§‹å›¾ç‰‡"},
                    "table_detection": {"type": "boolean", "description": "æ˜¯å¦å¯ç”¨è¡¨æ ¼æ£€æµ‹"}
                }
            }
        },
        "required": ["pdf_path"]
    }
}

def handle_pdf_conversion(arguments: Dict[str, Any]) -> str:
    """å¤„ç†PDFè½¬æ¢è¯·æ±‚"""
    from src.core.pipeline import ConversionPipeline
    
    pipeline = ConversionPipeline()
    pdf_path = Path(arguments["pdf_path"])
    
    result = pipeline.convert(
        pdf_path=pdf_path,
        output_path=arguments.get("output_directory"),
        **arguments.get("conversion_options", {})
    )
    
    return json.dumps({
        "status": "success",
        "output_file": str(result.output_path),
        "pages_processed": result.pages_processed,
        "conversion_time": result.conversion_time
    }, ensure_ascii=False)
```

### **3. Cursor/VSCode æ‰©å±•** â­â­â­â­

**é€‚ç”¨åœºæ™¯**: Cursorç¼–è¾‘å™¨ã€VSCode

```typescript:vscode-extension/src/extension.ts
import * as vscode from 'vscode';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export function activate(context: vscode.ExtensionContext) {
    
    // æ³¨å†ŒPDFè½¬Typstå‘½ä»¤
    const convertCommand = vscode.commands.registerCommand(
        'pdf-to-typst.convert', 
        async (uri?: vscode.Uri) => {
            try {
                let pdfPath: string;
                
                if (uri) {
                    pdfPath = uri.fsPath;
                } else {
                    // è®©ç”¨æˆ·é€‰æ‹©PDFæ–‡ä»¶
                    const result = await vscode.window.showOpenDialog({
                        canSelectFiles: true,
                        canSelectMany: false,
                        filters: {
                            'PDF Files': ['pdf']
                        }
                    });
                    
                    if (!result || result.length === 0) {
                        return;
                    }
                    
                    pdfPath = result[0].fsPath;
                }
                
                // æ˜¾ç¤ºè¿›åº¦
                await vscode.window.withProgress({
                    location: vscode.ProgressLocation.Notification,
                    title: "è½¬æ¢PDFåˆ°Typst",
                    cancellable: true
                }, async (progress, token) => {
                    
                    progress.report({ increment: 0, message: "å¼€å§‹è½¬æ¢..." });
                    
                    // è°ƒç”¨Pythonè½¬æ¢è„šæœ¬
                    const pythonScript = path.join(
                        context.extensionPath, 
                        'python', 
                        'convert_pdf.py'
                    );
                    
                    const command = `python "${pythonScript}" "${pdfPath}"`;
                    
                    try {
                        const { stdout, stderr } = await execAsync(command);
                        
                        if (stderr) {
                            throw new Error(stderr);
                        }
                        
                        const result = JSON.parse(stdout);
                        
                        progress.report({ increment: 100, message: "è½¬æ¢å®Œæˆï¼" });
                        
                        // è¯¢é—®æ˜¯å¦æ‰“å¼€è¾“å‡ºæ–‡ä»¶
                        const action = await vscode.window.showInformationMessage(
                            `è½¬æ¢å®Œæˆï¼è¾“å‡ºæ–‡ä»¶: ${result.output_file}`,
                            "æ‰“å¼€æ–‡ä»¶", "æ‰“å¼€ç›®å½•"
                        );
                        
                        if (action === "æ‰“å¼€æ–‡ä»¶") {
                            const doc = await vscode.workspace.openTextDocument(result.output_file);
                            await vscode.window.showTextDocument(doc);
                        } else if (action === "æ‰“å¼€ç›®å½•") {
                            const outputDir = path.dirname(result.output_file);
                            await vscode.commands.executeCommand('vscode.openFolder', vscode.Uri.file(outputDir));
                        }
                        
                    } catch (error) {
                        vscode.window.showErrorMessage(`è½¬æ¢å¤±è´¥: ${error.message}`);
                    }
                });
                
            } catch (error) {
                vscode.window.showErrorMessage(`æ“ä½œå¤±è´¥: ${error.message}`);
            }
        }
    );
    
    context.subscriptions.push(convertCommand);
}

export function deactivate() {}
```

### **4. Web APIæœåŠ¡** â­â­â­

**é€‚ç”¨åœºæ™¯**: ä»»ä½•æ”¯æŒHTTPè°ƒç”¨çš„AI Agent

```python:web_api/app.py
"""
PDFè½¬Typst Web APIæœåŠ¡
ä½¿ç”¨FastAPIæ„å»ºRESTfulæ¥å£
"""

from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import FileResponse
from pydantic import BaseModel
from pathlib import Path
import tempfile
import uuid
from typing import Optional

from src.core.pipeline import ConversionPipeline

app = FastAPI(
    title="PDFè½¬Typst API",
    description="å°†PDFæ–‡ä»¶è½¬æ¢ä¸ºTypstæ ¼å¼çš„Web APIæœåŠ¡",
    version="1.0.0"
)

class ConversionOptions(BaseModel):
    use_multimodal: bool = False
    preserve_images: bool = True
    table_detection: bool = True

class ConversionResult(BaseModel):
    task_id: str
    status: str
    output_file: Optional[str] = None
    pages_processed: Optional[int] = None
    conversion_time: Optional[float] = None
    error_message: Optional[str] = None

pipeline = ConversionPipeline()

@app.post("/convert", response_model=ConversionResult)
async def convert_pdf_to_typst(
    file: UploadFile = File(...),
    options: ConversionOptions = ConversionOptions()
):
    """è½¬æ¢PDFæ–‡ä»¶åˆ°Typstæ ¼å¼"""
    
    if not file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="åªæ”¯æŒPDFæ–‡ä»¶")
    
    task_id = str(uuid.uuid4())
    
    try:
        # ä¿å­˜ä¸Šä¼ çš„æ–‡ä»¶
        with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:
            content = await file.read()
            tmp_file.write(content)
            pdf_path = Path(tmp_file.name)
        
        # æ‰§è¡Œè½¬æ¢
        result = pipeline.convert(
            pdf_path=pdf_path,
            use_multimodal=options.use_multimodal,
            preserve_images=options.preserve_images,
            table_detection=options.table_detection
        )
        
        return ConversionResult(
            task_id=task_id,
            status="success",
            output_file=str(result.output_path),
            pages_processed=result.pages_processed,
            conversion_time=result.conversion_time
        )
        
    except Exception as e:
        return ConversionResult(
            task_id=task_id,
            status="error", 
            error_message=str(e)
        )
    
    finally:
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if pdf_path.exists():
            pdf_path.unlink()

@app.get("/download/{file_path}")
async def download_file(file_path: str):
    """ä¸‹è½½è½¬æ¢åçš„æ–‡ä»¶"""
    file_path = Path(file_path)
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="æ–‡ä»¶ä¸å­˜åœ¨")
    
    return FileResponse(
        path=file_path,
        filename=file_path.name,
        media_type='application/octet-stream'
    )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

## ğŸ“¦ éƒ¨ç½²å’Œé…ç½®

### **MCPæœåŠ¡é…ç½®** (æ¨è)

```json:claude_desktop_config.json
{
  "mcpServers": {
    "pdf-to-typst": {
      "command": "python",
      "args": ["/path/to/your/mcp_server/pdf_to_typst_server.py"],
      "env": {
        "PYTHONPATH": "/path/to/your/project"
      }
    }
  }
}
```

### **ä½¿ç”¨ç¤ºä¾‹**

ç”¨æˆ·åœ¨Claude Desktopä¸­å¯ä»¥è¿™æ ·ä½¿ç”¨ï¼š

```
è¯·å¸®æˆ‘å°†è¿™ä¸ªPDFæ–‡ä»¶è½¬æ¢ä¸ºTypstæ ¼å¼ï¼š/Users/username/document.pdf
```

Claudeä¼šè‡ªåŠ¨è°ƒç”¨æ‚¨çš„MCPæœåŠ¡å®Œæˆè½¬æ¢ã€‚

## ğŸ¯ æ¨èå®ç°é¡ºåº

1. **ä¼˜å…ˆå¼€å‘MCPæœåŠ¡** - æœ€ç¬¦åˆå½“å‰AI Agentç”Ÿæ€
2. **æ·»åŠ Web API** - æä¾›é€šç”¨çš„HTTPæ¥å£
3. **å¼€å‘VSCode/Cursoræ‰©å±•** - ä¸ºå¼€å‘è€…æä¾›ä¾¿åˆ©
4. **è€ƒè™‘OpenAI Function** - æ”¯æŒChatGPTç­‰å¹³å°

éœ€è¦æˆ‘å¸®æ‚¨å®ç°å…¶ä¸­ä»»ä½•ä¸€ä¸ªæ–¹æ¡ˆçš„è¯¦ç»†ä»£ç å—ï¼Ÿ

```python
"""
PDFè½¬Typst MCPæœåŠ¡å™¨
æ”¯æŒClaude Desktopã€Cursorç­‰MCPå®¢æˆ·ç«¯
"""

import asyncio
import json
import logging
from pathlib import Path
from typing import Any, Dict, List, Optional

# MCPç›¸å…³å¯¼å…¥
from mcp import ClientSession, StdioServerSession
from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.types import (
    CallToolRequest,
    CallToolResult,
    ListToolsRequest, 
    ListToolsResult,
    Tool,
    TextContent
)

# å¯¼å…¥æ‚¨ç°æœ‰çš„PDFè½¬æ¢åŠŸèƒ½
from src.core.pdf_parser import HybridPDFParser
from src.core.typst_generator import TypstGenerator
from src.core.pipeline import ConversionPipeline

logger = logging.getLogger(__name__)

class PDFToTypstMCPServer:
    """PDFè½¬Typst MCPæœåŠ¡å™¨"""
    
    def __init__(self):
        self.server = Server("pdf-to-typst")
        self.pipeline = ConversionPipeline()
        self._setup_tools()
    
    def _setup_tools(self):
        """è®¾ç½®MCPå·¥å…·"""
        
        @self.server.list_tools()
        async def handle_list_tools() -> ListToolsResult:
            return ListToolsResult(
                tools=[
                    Tool(
                        name="convert_pdf_to_typst",
                        description="å°†PDFæ–‡ä»¶è½¬æ¢ä¸ºTypstæ ¼å¼",
                        inputSchema={
                            "type": "object",
                            "properties": {
                                "pdf_path": {
                                    "type": "string",
                                    "description": "PDFæ–‡ä»¶è·¯å¾„"
                                },
                                "output_path": {
                                    "type": "string", 
                                    "description": "è¾“å‡ºTypstæ–‡ä»¶è·¯å¾„ï¼ˆå¯é€‰ï¼‰"
                                },
                                "use_multimodal": {
                                    "type": "boolean",
                                    "description": "æ˜¯å¦ä½¿ç”¨å¤šæ¨¡æ€å¤§æ¨¡å‹å¢å¼ºè½¬æ¢ï¼ˆå¯é€‰ï¼‰"
                                }
                            },
                            "required": ["pdf_path"]
                        }
                    ),
                    Tool(
                        name="analyze_pdf_structure",
                        description="åˆ†æPDFæ–‡æ¡£ç»“æ„ï¼Œè¿”å›é¡µé¢ä¿¡æ¯å’Œå…ƒç´ ç»Ÿè®¡",
                        inputSchema={
                            "type": "object", 
                            "properties": {
                                "pdf_path": {
                                    "type": "string",
                                    "description": "PDFæ–‡ä»¶è·¯å¾„"
                                }
                            },
                            "required": ["pdf_path"]
                        }
                    ),
                    Tool(
                        name="preview_typst_output",
                        description="é¢„è§ˆPDFè½¬æ¢åçš„Typstä»£ç ç‰‡æ®µ",
                        inputSchema={
                            "type": "object",
                            "properties": {
                                "pdf_path": {
                                    "type": "string", 
                                    "description": "PDFæ–‡ä»¶è·¯å¾„"
                                },
                                "page_range": {
                                    "type": "string",
                                    "description": "é¡µé¢èŒƒå›´ï¼Œå¦‚'1-3'æˆ–'1,3,5'"
                                }
                            },
                            "required": ["pdf_path"]
                        }
                    )
                ]
            )
        
        @self.server.call_tool()
        async def handle_call_tool(
            name: str, arguments: Dict[str, Any]
        ) -> CallToolResult:
            try:
                if name == "convert_pdf_to_typst":
                    return await self._convert_pdf_to_typst(arguments)
                elif name == "analyze_pdf_structure":
                    return await self._analyze_pdf_structure(arguments)
                elif name == "preview_typst_output":
                    return await self._preview_typst_output(arguments)
                else:
                    raise ValueError(f"æœªçŸ¥å·¥å…·: {name}")
            
            except Exception as e:
                logger.error(f"å·¥å…·è°ƒç”¨å¤±è´¥ {name}: {e}")
                return CallToolResult(
                    content=[TextContent(
                        type="text",
                        text=f"è½¬æ¢å¤±è´¥: {str(e)}"
                    )],
                    isError=True
                )
    
    async def _convert_pdf_to_typst(self, args: Dict[str, Any]) -> CallToolResult:
        """æ‰§è¡ŒPDFåˆ°Typstè½¬æ¢"""
        pdf_path = Path(args["pdf_path"])
        output_path = args.get("output_path")
        use_multimodal = args.get("use_multimodal", False)
        
        if not pdf_path.exists():
            raise FileNotFoundError(f"PDFæ–‡ä»¶ä¸å­˜åœ¨: {pdf_path}")
        
        # æ‰§è¡Œè½¬æ¢
        result = await asyncio.to_thread(
            self.pipeline.convert,
            pdf_path=pdf_path,
            output_path=output_path,
            use_multimodal=use_multimodal
        )
        
        return CallToolResult(
            content=[TextContent(
                type="text", 
                text=f"è½¬æ¢å®Œæˆï¼\nè¾“å‡ºæ–‡ä»¶: {result.output_path}\n"
                     f"å¤„ç†é¡µæ•°: {result.pages_processed}\n"
                     f"è½¬æ¢æ—¶é—´: {result.conversion_time:.2f}ç§’"
            )]
        )
    
    async def _analyze_pdf_structure(self, args: Dict[str, Any]) -> CallToolResult:
        """åˆ†æPDFç»“æ„"""
        pdf_path = Path(args["pdf_path"])
        
        parser = HybridPDFParser()
        metadata = parser.extract_metadata(pdf_path)
        pages_info = parser.get_page_info(pdf_path)
        
        analysis = {
            "æ–‡æ¡£ä¿¡æ¯": {
                "æ ‡é¢˜": metadata.title or "æœªçŸ¥",
                "ä½œè€…": metadata.author or "æœªçŸ¥", 
                "é¡µæ•°": metadata.pages
            },
            "é¡µé¢ä¿¡æ¯": [
                {
                    "é¡µç ": page.number,
                    "å°ºå¯¸": f"{page.width:.1f}x{page.height:.1f}",
                    "æ—‹è½¬": page.rotation
                }
                for page in pages_info[:5]  # åªæ˜¾ç¤ºå‰5é¡µ
            ]
        }
        
        return CallToolResult(
            content=[TextContent(
                type="text",
                text=f"PDFç»“æ„åˆ†æ:\n{json.dumps(analysis, ensure_ascii=False, indent=2)}"
            )]
        )
    
    async def _preview_typst_output(self, args: Dict[str, Any]) -> CallToolResult:
        """é¢„è§ˆTypstè¾“å‡º"""
        pdf_path = Path(args["pdf_path"])
        page_range = args.get("page_range", "1")
        
        # è§£æé¡µé¢èŒƒå›´
        pages = self._parse_page_range(page_range)
        
        # æå–æŒ‡å®šé¡µé¢å†…å®¹å¹¶ç”ŸæˆTypsté¢„è§ˆ
        preview = await asyncio.to_thread(
            self.pipeline.generate_preview,
            pdf_path=pdf_path,
            pages=pages
        )
        
        return CallToolResult(
            content=[TextContent(
                type="text",
                text=f"Typstä»£ç é¢„è§ˆ (é¡µé¢ {page_range}):\n\n```typst\n{preview}\n```"
            )]
        )
    
    def _parse_page_range(self, page_range: str) -> List[int]:
        """è§£æé¡µé¢èŒƒå›´å­—ç¬¦ä¸²"""
        pages = []
        for part in page_range.split(','):
            if '-' in part:
                start, end = map(int, part.split('-'))
                pages.extend(range(start, end + 1))
            else:
                pages.append(int(part))
        return pages
    
    async def run(self):
        """è¿è¡ŒMCPæœåŠ¡å™¨"""
        async with StdioServerSession() as session:
            await self.server.run(session)

async def main():
    """ä¸»å‡½æ•°"""
    server = PDFToTypstMCPServer()
    await server.run()

if __name__ == "__main__":
    asyncio.run(main())
```

```python
"""
OpenAI Function Calling æ’ä»¶
"""

import json
from typing import Dict, Any
from pathlib import Path

# OpenAI Function å®šä¹‰
PDF_TO_TYPST_FUNCTION = {
    "name": "convert_pdf_to_typst",
    "description": "å°†PDFæ–‡ä»¶è½¬æ¢ä¸ºTypstæ ¼å¼ï¼Œæ”¯æŒå›¾æ–‡æ··æ’ã€è¡¨æ ¼å’Œæ•°å­¦å…¬å¼",
    "parameters": {
        "type": "object",
        "properties": {
            "pdf_path": {
                "type": "string",
                "description": "PDFæ–‡ä»¶çš„å®Œæ•´è·¯å¾„"
            },
            "output_directory": {
                "type": "string", 
                "description": "è¾“å‡ºç›®å½•è·¯å¾„ï¼ˆå¯é€‰ï¼‰"
            },
            "conversion_options": {
                "type": "object",
                "properties": {
                    "use_multimodal": {"type": "boolean", "description": "æ˜¯å¦ä½¿ç”¨å¤šæ¨¡æ€AIå¢å¼º"},
                    "preserve_images": {"type": "boolean", "description": "æ˜¯å¦ä¿ç•™åŸå§‹å›¾ç‰‡"},
                    "table_detection": {"type": "boolean", "description": "æ˜¯å¦å¯ç”¨è¡¨æ ¼æ£€æµ‹"}
                }
            }
        },
        "required": ["pdf_path"]
    }
}

def handle_pdf_conversion(arguments: Dict[str, Any]) -> str:
    """å¤„ç†PDFè½¬æ¢è¯·æ±‚"""
    from src.core.pipeline import ConversionPipeline
    
    pipeline = ConversionPipeline()
    pdf_path = Path(arguments["pdf_path"])
    
    result = pipeline.convert(
        pdf_path=pdf_path,
        output_path=arguments.get("output_directory"),
        **arguments.get("conversion_options", {})
    )
    
    return json.dumps({
        "status": "success",
        "output_file": str(result.output_path),
        "pages_processed": result.pages_processed,
        "conversion_time": result.conversion_time
    }, ensure_ascii=False)
```

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export function activate(context: vscode.ExtensionContext) {
    
    // æ³¨å†ŒPDFè½¬Typstå‘½ä»¤
    const convertCommand = vscode.commands.registerCommand(
        'pdf-to-typst.convert', 
        async (uri?: vscode.Uri) => {
            try {
                let pdfPath: string;
                
                if (uri) {
                    pdfPath = uri.fsPath;
                } else {
                    // è®©ç”¨æˆ·é€‰æ‹©PDFæ–‡ä»¶
                    const result = await vscode.window.showOpenDialog({
                        canSelectFiles: true,
                        canSelectMany: false,
                        filters: {
                            'PDF Files': ['pdf']
                        }
                    });
                    
                    if (!result || result.length === 0) {
                        return;
                    }
                    
                    pdfPath = result[0].fsPath;
                }
                
                // æ˜¾ç¤ºè¿›åº¦
                await vscode.window.withProgress({
                    location: vscode.ProgressLocation.Notification,
                    title: "è½¬æ¢PDFåˆ°Typst",
                    cancellable: true
                }, async (progress, token) => {
                    
                    progress.report({ increment: 0, message: "å¼€å§‹è½¬æ¢..." });
                    
                    // è°ƒç”¨Pythonè½¬æ¢è„šæœ¬
                    const pythonScript = path.join(
                        context.extensionPath, 
                        'python', 
                        'convert_pdf.py'
                    );
                    
                    const command = `python "${pythonScript}" "${pdfPath}"`;
                    
                    try {
                        const { stdout, stderr } = await execAsync(command);
                        
                        if (stderr) {
                            throw new Error(stderr);
                        }
                        
                        const result = JSON.parse(stdout);
                        
                        progress.report({ increment: 100, message: "è½¬æ¢å®Œæˆï¼" });
                        
                        // è¯¢é—®æ˜¯å¦æ‰“å¼€è¾“å‡ºæ–‡ä»¶
                        const action = await vscode.window.showInformationMessage(
                            `è½¬æ¢å®Œæˆï¼è¾“å‡ºæ–‡ä»¶: ${result.output_file}`,
                            "æ‰“å¼€æ–‡ä»¶", "æ‰“å¼€ç›®å½•"
                        );
                        
                        if (action === "æ‰“å¼€æ–‡ä»¶") {
                            const doc = await vscode.workspace.openTextDocument(result.output_file);
                            await vscode.window.showTextDocument(doc);
                        } else if (action === "æ‰“å¼€ç›®å½•") {
                            const outputDir = path.dirname(result.output_file);
                            await vscode.commands.executeCommand('vscode.openFolder', vscode.Uri.file(outputDir));
                        }
                        
                    } catch (error) {
                        vscode.window.showErrorMessage(`è½¬æ¢å¤±è´¥: ${error.message}`);
                    }
                });
                
            } catch (error) {
                vscode.window.showErrorMessage(`æ“ä½œå¤±è´¥: ${error.message}`);
            }
        }
    );
    
    context.subscriptions.push(convertCommand);
}

export function deactivate() {}
```

```python
"""
PDFè½¬Typst Web APIæœåŠ¡
ä½¿ç”¨FastAPIæ„å»ºRESTfulæ¥å£
"""

from fastapi import FastAPI, UploadFile, File, HTTPException
from fastapi.responses import FileResponse
from pydantic import BaseModel
from pathlib import Path
import tempfile
import uuid
from typing import Optional

from src.core.pipeline import ConversionPipeline

app = FastAPI(
    title="PDFè½¬Typst API",
    description="å°†PDFæ–‡ä»¶è½¬æ¢ä¸ºTypstæ ¼å¼çš„Web APIæœåŠ¡",
    version="1.0.0"
)

class ConversionOptions(BaseModel):
    use_multimodal: bool = False
    preserve_images: bool = True
    table_detection: bool = True

class ConversionResult(BaseModel):
    task_id: str
    status: str
    output_file: Optional[str] = None
    pages_processed: Optional[int] = None
    conversion_time: Optional[float] = None
    error_message: Optional[str] = None

pipeline = ConversionPipeline()

@app.post("/convert", response_model=ConversionResult)
async def convert_pdf_to_typst(
    file: UploadFile = File(...),
    options: ConversionOptions = ConversionOptions()
):
    """è½¬æ¢PDFæ–‡ä»¶åˆ°Typstæ ¼å¼"""
    
    if not file.filename.endswith('.pdf'):
        raise HTTPException(status_code=400, detail="åªæ”¯æŒPDFæ–‡ä»¶")
    
    task_id = str(uuid.uuid4())
    
    try:
        # ä¿å­˜ä¸Šä¼ çš„æ–‡ä»¶
        with tempfile.NamedTemporaryFile(delete=False, suffix='.pdf') as tmp_file:
            content = await file.read()
            tmp_file.write(content)
            pdf_path = Path(tmp_file.name)
        
        # æ‰§è¡Œè½¬æ¢
        result = pipeline.convert(
            pdf_path=pdf_path,
            use_multimodal=options.use_multimodal,
            preserve_images=options.preserve_images,
            table_detection=options.table_detection
        )
        
        return ConversionResult(
            task_id=task_id,
            status="success",
            output_file=str(result.output_path),
            pages_processed=result.pages_processed,
            conversion_time=result.conversion_time
        )
        
    except Exception as e:
        return ConversionResult(
            task_id=task_id,
            status="error", 
            error_message=str(e)
        )
    
    finally:
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if pdf_path.exists():
            pdf_path.unlink()

@app.get("/download/{file_path}")
async def download_file(file_path: str):
    """ä¸‹è½½è½¬æ¢åçš„æ–‡ä»¶"""
    file_path = Path(file_path)
    if not file_path.exists():
        raise HTTPException(status_code=404, detail="æ–‡ä»¶ä¸å­˜åœ¨")
    
    return FileResponse(
        path=file_path,
        filename=file_path.name,
        media_type='application/octet-stream'
    )

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

```json
{
  "mcpServers": {
    "pdf-to-typst": {
      "command": "python",
      "args": ["/path/to/your/mcp_server/pdf_to_typst_server.py"],
      "env": {
        "PYTHONPATH": "/path/to/your/project"
      }
    }
  }
}
```

```plaintext
è¯·å¸®æˆ‘å°†è¿™ä¸ªPDFæ–‡ä»¶è½¬æ¢ä¸ºTypstæ ¼å¼ï¼š/Users/username/document.pdf
```

---

**User**

å¦‚æœå¼€å‘æˆMCPæœåŠ¡æˆ–æ’ä»¶ï¼Œpdfè½¬ä¸ºTypstçš„è¿‡ç¨‹å¯ä»¥ä½¿ç”¨Agentçš„AIå¤§æ¨¡å‹æ¥è¯†åˆ«é¡µé¢å¸ƒå±€å’Œç”ŸæˆTypstå—

---

**Cursor**

éå¸¸å¥½çš„æƒ³æ³•ï¼è¿™æ ·å¯ä»¥å……åˆ†åˆ©ç”¨Agentçš„AIå¤§æ¨¡å‹èƒ½åŠ›æ¥æå‡è½¬æ¢è´¨é‡ã€‚è®©æˆ‘ä¸ºæ‚¨è®¾è®¡ä¸€ä¸ªæ–¹æ¡ˆï¼Œè®©MCPæœåŠ¡èƒ½å¤Ÿè°ƒç”¨Agentçš„AIå¤§æ¨¡å‹æ¥è¿›è¡Œé¡µé¢å¸ƒå±€è¯†åˆ«å’ŒTypstç”Ÿæˆã€‚

ç»å¯¹å¯ä»¥ï¼è¿™æ˜¯ä¸€ä¸ªéå¸¸èªæ˜çš„è®¾è®¡æ€è·¯ã€‚é€šè¿‡MCPåè®®ï¼Œæ‚¨çš„æœåŠ¡å¯ä»¥ä¸Agentçš„AIå¤§æ¨¡å‹è¿›è¡ŒåŒå‘é€šä¿¡ï¼Œå……åˆ†åˆ©ç”¨å…¶å¤šæ¨¡æ€èƒ½åŠ›æ¥è¯†åˆ«é¡µé¢å¸ƒå±€å’Œç”ŸæˆTypstä»£ç ã€‚è®©æˆ‘ä¸ºæ‚¨è®¾è®¡å…·ä½“çš„å®ç°æ–¹æ¡ˆï¼š

## ğŸ”„ MCPåŒå‘é€šä¿¡æ¶æ„

### **æ ¸å¿ƒæ€è·¯**
1. **MCPæœåŠ¡**è´Ÿè´£PDFè§£æã€å›¾åƒæå–ã€æ–‡ä»¶ç®¡ç†
2. **Agentçš„AIå¤§æ¨¡å‹**è´Ÿè´£é¡µé¢å¸ƒå±€è¯†åˆ«å’ŒTypstä»£ç ç”Ÿæˆ
3. **é€šè¿‡MCP Resourceså’ŒPrompts**å®ç°åŒå‘æ•°æ®ä¼ é€’

## ğŸ“‹ å®ç°æ–¹æ¡ˆ

```python
"""
æ™ºèƒ½PDFè½¬Typst MCPæœåŠ¡
åˆ©ç”¨Agentçš„AIå¤§æ¨¡å‹è¿›è¡Œé¡µé¢å¸ƒå±€è¯†åˆ«å’Œä»£ç ç”Ÿæˆ
"""

import asyncio
import base64
import json
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional

from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.types import (
    CallToolRequest, CallToolResult, Tool, TextContent, ImageContent,
    ListResourcesRequest, ListResourcesResult, Resource,
    ReadResourceRequest, ReadResourceResult, ResourceContents,
    ListPromptsRequest, ListPromptsResult, Prompt,
    GetPromptRequest, GetPromptResult, PromptMessage
)

# å¯¼å…¥ç°æœ‰çš„PDFå¤„ç†åŠŸèƒ½
from src.core.pdf_parser import HybridPDFParser
from src.core.models import PageInfo, TextBlock, Table, Image

class IntelligentPDFToTypstServer:
    """æ™ºèƒ½PDFè½¬Typst MCPæœåŠ¡å™¨"""
    
    def __init__(self):
        self.server = Server("intelligent-pdf-to-typst")
        self.parser = HybridPDFParser()
        self.temp_files = {}  # å­˜å‚¨ä¸´æ—¶æ–‡ä»¶è·¯å¾„
        self.conversion_sessions = {}  # å­˜å‚¨è½¬æ¢ä¼šè¯æ•°æ®
        self._setup_handlers()
    
    def _setup_handlers(self):
        """è®¾ç½®MCPå¤„ç†å™¨"""
        
        @self.server.list_tools()
        async def list_tools() -> List[Tool]:
            return [
                Tool(
                    name="start_pdf_conversion",
                    description="å¼€å§‹PDFè½¬Typstè½¬æ¢æµç¨‹ï¼Œæå–é¡µé¢å¹¶å‡†å¤‡ä¾›AIåˆ†æ",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "pdf_path": {"type": "string", "description": "PDFæ–‡ä»¶è·¯å¾„"},
                            "session_id": {"type": "string", "description": "è½¬æ¢ä¼šè¯ID"}
                        },
                        "required": ["pdf_path", "session_id"]
                    }
                ),
                Tool(
                    name="finalize_conversion", 
                    description="å®Œæˆè½¬æ¢ï¼Œæ•´åˆAIç”Ÿæˆçš„Typstä»£ç å¹¶è¾“å‡ºæ–‡ä»¶",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "session_id": {"type": "string", "description": "è½¬æ¢ä¼šè¯ID"},
                            "output_path": {"type": "string", "description": "è¾“å‡ºæ–‡ä»¶è·¯å¾„"}
                        },
                        "required": ["session_id"]
                    }
                )
            ]
        
        @self.server.call_tool()
        async def call_tool(name: str, arguments: Dict[str, Any]) -> CallToolResult:
            if name == "start_pdf_conversion":
                return await self._start_conversion(arguments)
            elif name == "finalize_conversion":
                return await self._finalize_conversion(arguments)
            else:
                raise ValueError(f"Unknown tool: {name}")
        
        @self.server.list_resources()
        async def list_resources() -> List[Resource]:
            """åˆ—å‡ºå¯ç”¨çš„èµ„æºï¼ˆé¡µé¢å›¾ç‰‡ã€æ–‡æœ¬å†…å®¹ç­‰ï¼‰"""
            resources = []
            
            for session_id, session_data in self.conversion_sessions.items():
                # ä¸ºæ¯ä¸ªé¡µé¢æ·»åŠ å›¾ç‰‡èµ„æº
                for page_num in range(1, session_data["total_pages"] + 1):
                    resources.append(Resource(
                        uri=f"pdf-page://{session_id}/page-{page_num}/image",
                        name=f"ç¬¬{page_num}é¡µå›¾ç‰‡",
                        description=f"PDFç¬¬{page_num}é¡µçš„é«˜åˆ†è¾¨ç‡å›¾ç‰‡ï¼Œç”¨äºå¸ƒå±€è¯†åˆ«",
                        mimeType="image/png"
                    ))
                    
                    resources.append(Resource(
                        uri=f"pdf-page://{session_id}/page-{page_num}/text",
                        name=f"ç¬¬{page_num}é¡µæ–‡æœ¬",
                        description=f"PDFç¬¬{page_num}é¡µçš„æ–‡æœ¬å†…å®¹å’Œç»“æ„ä¿¡æ¯",
                        mimeType="application/json"
                    ))
            
            return resources
        
        @self.server.read_resource()
        async def read_resource(uri: str) -> ResourceContents:
            """è¯»å–èµ„æºå†…å®¹"""
            # è§£æURI: pdf-page://session_id/page-N/type
            parts = uri.replace("pdf-page://", "").split("/")
            session_id, page_part, resource_type = parts
            page_num = int(page_part.split("-")[1])
            
            session_data = self.conversion_sessions.get(session_id)
            if not session_data:
                raise ValueError(f"æœªæ‰¾åˆ°è½¬æ¢ä¼šè¯: {session_id}")
            
            if resource_type == "image":
                # è¿”å›é¡µé¢å›¾ç‰‡
                image_data = session_data["page_images"][page_num - 1]
                return ResourceContents(
                    uri=uri,
                    mimeType="image/png",
                    text=base64.b64encode(image_data).decode()
                )
            
            elif resource_type == "text":
                # è¿”å›é¡µé¢æ–‡æœ¬å’Œç»“æ„ä¿¡æ¯
                page_data = session_data["page_data"][page_num - 1]
                return ResourceContents(
                    uri=uri,
                    mimeType="application/json",
                    text=json.dumps(page_data, ensure_ascii=False, indent=2)
                )
            
            else:
                raise ValueError(f"æœªçŸ¥èµ„æºç±»å‹: {resource_type}")
        
        @self.server.list_prompts()
        async def list_prompts() -> List[Prompt]:
            """åˆ—å‡ºå¯ç”¨çš„æç¤ºæ¨¡æ¿"""
            return [
                Prompt(
                    name="analyze_pdf_layout",
                    description="åˆ†æPDFé¡µé¢å¸ƒå±€å¹¶ç”ŸæˆTypstä»£ç çš„æç¤ºæ¨¡æ¿"
                ),
                Prompt(
                    name="generate_typst_code",
                    description="æ ¹æ®é¡µé¢åˆ†æç»“æœç”ŸæˆTypstä»£ç çš„æç¤ºæ¨¡æ¿"
                )
            ]
        
        @self.server.get_prompt()
        async def get_prompt(name: str, arguments: Optional[Dict[str, Any]] = None) -> List[PromptMessage]:
            """è·å–æç¤ºæ¨¡æ¿å†…å®¹"""
            if name == "analyze_pdf_layout":
                return self._get_layout_analysis_prompt(arguments)
            elif name == "generate_typst_code":
                return self._get_typst_generation_prompt(arguments)
            else:
                raise ValueError(f"Unknown prompt: {name}")
    
    async def _start_conversion(self, args: Dict[str, Any]) -> CallToolResult:
        """å¼€å§‹PDFè½¬æ¢æµç¨‹"""
        pdf_path = Path(args["pdf_path"])
        session_id = args["session_id"]
        
        if not pdf_path.exists():
            raise FileNotFoundError(f"PDFæ–‡ä»¶ä¸å­˜åœ¨: {pdf_path}")
        
        try:
            # æå–PDFå…ƒæ•°æ®å’Œé¡µé¢ä¿¡æ¯
            metadata = self.parser.extract_metadata(pdf_path)
            pages_info = self.parser.get_page_info(pdf_path)
            
            # å°†æ¯é¡µè½¬æ¢ä¸ºé«˜åˆ†è¾¨ç‡å›¾ç‰‡
            page_images = await asyncio.to_thread(self._extract_page_images, pdf_path)
            
            # æå–æ¯é¡µçš„æ–‡æœ¬å’Œç»“æ„ä¿¡æ¯
            page_data = await asyncio.to_thread(self._extract_page_data, pdf_path)
            
            # å­˜å‚¨ä¼šè¯æ•°æ®
            self.conversion_sessions[session_id] = {
                "pdf_path": str(pdf_path),
                "metadata": metadata.__dict__,
                "total_pages": len(pages_info),
                "page_images": page_images,
                "page_data": page_data,
                "typst_pages": {}  # å­˜å‚¨AIç”Ÿæˆçš„æ¯é¡µTypstä»£ç 
            }
            
            # æ„å»ºè¿”å›æ¶ˆæ¯ï¼Œå¼•å¯¼AIåˆ†æé¡µé¢
            analysis_guide = self._build_analysis_guide(session_id, len(pages_info))
            
            return CallToolResult(
                content=[TextContent(
                    type="text",
                    text=f"PDFè½¬æ¢ä¼šè¯å·²å¯åŠ¨ï¼\n\n"
                         f"ğŸ“„ æ–‡æ¡£ä¿¡æ¯:\n"
                         f"- æ–‡ä»¶: {pdf_path.name}\n"
                         f"- é¡µæ•°: {len(pages_info)}\n"
                         f"- ä¼šè¯ID: {session_id}\n\n"
                         f"ğŸ” ç°åœ¨è¯·ä½¿ç”¨ä»¥ä¸‹æ­¥éª¤åˆ†æé¡µé¢å¸ƒå±€:\n\n"
                         f"{analysis_guide}"
                )]
            )
            
        except Exception as e:
            return CallToolResult(
                content=[TextContent(type="text", text=f"è½¬æ¢å¯åŠ¨å¤±è´¥: {str(e)}")],
                isError=True
            )
    
    def _build_analysis_guide(self, session_id: str, total_pages: int) -> str:
        """æ„å»ºé¡µé¢åˆ†ææŒ‡å¯¼"""
        guide = "è¯·æŒ‰ä»¥ä¸‹æ­¥éª¤åˆ†ææ¯ä¸ªé¡µé¢:\n\n"
        
        for page_num in range(1, min(total_pages + 1, 4)):  # æœ€å¤šæ˜¾ç¤ºå‰3é¡µçš„æŒ‡å¯¼
            guide += f"**ç¬¬{page_num}é¡µåˆ†æ:**\n"
            guide += f"1. æŸ¥çœ‹é¡µé¢å›¾ç‰‡: `pdf-page://{session_id}/page-{page_num}/image`\n"
            guide += f"2. æŸ¥çœ‹æ–‡æœ¬å†…å®¹: `pdf-page://{session_id}/page-{page_num}/text`\n"
            guide += f"3. ä½¿ç”¨ `analyze_pdf_layout` æç¤ºæ¨¡æ¿åˆ†æå¸ƒå±€\n"
            guide += f"4. ä½¿ç”¨ `generate_typst_code` æç¤ºæ¨¡æ¿ç”Ÿæˆä»£ç \n\n"
        
        if total_pages > 3:
            guide += f"...ä»¥åŠå…¶ä½™ {total_pages - 3} é¡µ\n\n"
        
        guide += "å®Œæˆæ‰€æœ‰é¡µé¢åˆ†æåï¼Œè¯·è°ƒç”¨ `finalize_conversion` å®Œæˆè½¬æ¢ã€‚"
        
        return guide
    
    def _get_layout_analysis_prompt(self, args: Optional[Dict[str, Any]]) -> List[PromptMessage]:
        """è·å–å¸ƒå±€åˆ†ææç¤º"""
        return [
            PromptMessage(
                role="user",
                content=TextContent(
                    type="text",
                    text="""ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ–‡æ¡£å¸ƒå±€åˆ†æä¸“å®¶ã€‚è¯·åˆ†æè¿™ä¸ªPDFé¡µé¢çš„å¸ƒå±€ç»“æ„ï¼ŒåŒ…æ‹¬ï¼š

1. **é¡µé¢æ•´ä½“å¸ƒå±€**: å•æ /åŒæ /å¤šæ å¸ƒå±€
2. **æ–‡æœ¬å±‚æ¬¡**: æ ‡é¢˜ã€å‰¯æ ‡é¢˜ã€æ­£æ–‡ã€å¼•ç”¨ç­‰
3. **ç‰¹æ®Šå…ƒç´ **: è¡¨æ ¼ã€å›¾ç‰‡ã€å…¬å¼ã€åˆ—è¡¨ç­‰
4. **æ’ç‰ˆç‰¹å¾**: å­—ä½“å¤§å°ã€è¡Œè·ã€æ®µè½é—´è·ã€å¯¹é½æ–¹å¼ç­‰

è¯·ç»“åˆé¡µé¢å›¾ç‰‡å’Œæ–‡æœ¬å†…å®¹ï¼Œè¾“å‡ºè¯¦ç»†çš„å¸ƒå±€åˆ†æç»“æœï¼Œæ ¼å¼å¦‚ä¸‹ï¼š

```json
{
  "layout_type": "single_column|double_column|multi_column",
  "elements": [
    {
      "type": "title|subtitle|paragraph|table|image|formula|list",
      "content": "å…ƒç´ å†…å®¹",
      "position": {"x": 0, "y": 0, "width": 0, "height": 0},
      "style": {
        "font_size": 12,
        "font_weight": "normal|bold",
        "alignment": "left|center|right|justify"
      }
    }
  ]
}
```"""
                )
            )
        ]
    
    def _get_typst_generation_prompt(self, args: Optional[Dict[str, Any]]) -> List[PromptMessage]:
        """è·å–Typstä»£ç ç”Ÿæˆæç¤º"""
        return [
            PromptMessage(
                role="user", 
                content=TextContent(
                    type="text",
                    text="""åŸºäºé¡µé¢å¸ƒå±€åˆ†æç»“æœï¼Œè¯·ç”Ÿæˆå¯¹åº”çš„Typstä»£ç ã€‚è¦æ±‚ï¼š

1. **å‡†ç¡®é‡ç°å¸ƒå±€**: ä¸¥æ ¼æŒ‰ç…§åŸé¡µé¢çš„å¸ƒå±€ç»“æ„ç”Ÿæˆä»£ç 
2. **æ­£ç¡®çš„è¯­æ³•**: ä½¿ç”¨æ­£ç¡®çš„Typstè¯­æ³•å’Œå‡½æ•°
3. **æ ·å¼åŒ¹é…**: å­—ä½“ã€å¤§å°ã€é¢œè‰²ã€å¯¹é½ç­‰æ ·å¼è¦åŒ¹é…åŸæ–‡æ¡£
4. **ç»“æ„åŒ–ä»£ç **: ä»£ç è¦æ¸…æ™°ã€æœ‰å±‚æ¬¡ã€æ˜“äºé˜…è¯»

ç”Ÿæˆçš„Typstä»£ç åº”è¯¥åŒ…æ‹¬ï¼š
- é¡µé¢è®¾ç½®ï¼ˆå°ºå¯¸ã€è¾¹è·ç­‰ï¼‰
- å­—ä½“å’Œæ ·å¼å®šä¹‰
- å†…å®¹ç»“æ„ï¼ˆæ ‡é¢˜ã€æ®µè½ã€è¡¨æ ¼ç­‰ï¼‰
- å›¾ç‰‡å¼•ç”¨ï¼ˆå¦‚æœæœ‰ï¼‰

è¯·ç›´æ¥è¾“å‡ºTypstä»£ç ï¼Œä¸éœ€è¦é¢å¤–çš„è§£é‡Šã€‚"""
                )
            )
        ]
    
    def _extract_page_images(self, pdf_path: Path) -> List[bytes]:
        """æå–é¡µé¢å›¾ç‰‡"""
        import fitz  # PyMuPDF
        
        images = []
        doc = fitz.open(pdf_path)
        
        for page_num in range(doc.page_count):
            page = doc[page_num]
            # ä»¥é«˜DPIæ¸²æŸ“é¡µé¢
            mat = fitz.Matrix(2.0, 2.0)  # 2å€ç¼©æ”¾
            pix = page.get_pixmap(matrix=mat)
            images.append(pix.tobytes("png"))
        
        doc.close()
        return images
    
    def _extract_page_data(self, pdf_path: Path) -> List[Dict[str, Any]]:
        """æå–é¡µé¢æ–‡æœ¬å’Œç»“æ„æ•°æ®"""
        text_blocks = self.parser.extract_text(pdf_path)
        tables = self.parser.extract_tables(pdf_path)
        images = self.parser.extract_images(pdf_path)
        
        # æŒ‰é¡µé¢ç»„ç»‡æ•°æ®
        pages_data = {}
        
        # ç»„ç»‡æ–‡æœ¬å—
        for block in text_blocks:
            page_num = block.page
            if page_num not in pages_data:
                pages_data[page_num] = {"text_blocks": [], "tables": [], "images": []}
            pages_data[page_num]["text_blocks"].append({
                "text": block.text,
                "bbox": [block.bbox.x0, block.bbox.y0, block.bbox.x1, block.bbox.y1],
                "font": {
                    "name": block.font.name,
                    "size": block.font.size,
                    "styles": [style.value for style in block.font.styles]
                }
            })
        
        # ç»„ç»‡è¡¨æ ¼
        for table in tables:
            page_num = table.page
            if page_num not in pages_data:
                pages_data[page_num] = {"text_blocks": [], "tables": [], "images": []}
            pages_data[page_num]["tables"].append({
                "rows": table.rows,
                "cols": table.cols,
                "cells": [{"text": cell.text, "row": cell.row, "col": cell.col} for cell in table.cells],
                "bbox": [table.bbox.x0, table.bbox.y0, table.bbox.x1, table.bbox.y1]
            })
        
        # ç»„ç»‡å›¾ç‰‡
        for image in images:
            page_num = image.page
            if page_num not in pages_data:
                pages_data[page_num] = {"text_blocks": [], "tables": [], "images": []}
            pages_data[page_num]["images"].append({
                "filename": image.filename,
                "bbox": [image.bbox.x0, image.bbox.y0, image.bbox.x1, image.bbox.y1],
                "width": image.width,
                "height": image.height
            })
        
        # è½¬æ¢ä¸ºåˆ—è¡¨æ ¼å¼
        result = []
        max_page = max(pages_data.keys()) if pages_data else 0
        
        for page_num in range(1, max_page + 1):
            result.append(pages_data.get(page_num, {"text_blocks": [], "tables": [], "images": []}))
        
        return result
    
    async def _finalize_conversion(self, args: Dict[str, Any]) -> CallToolResult:
        """å®Œæˆè½¬æ¢æµç¨‹"""
        session_id = args["session_id"]
        output_path = args.get("output_path")
        
        session_data = self.conversion_sessions.get(session_id)
        if not session_data:
            raise ValueError(f"æœªæ‰¾åˆ°è½¬æ¢ä¼šè¯: {session_id}")
        
        try:
            # è¿™é‡Œå‡è®¾AIå·²ç»é€šè¿‡å…¶ä»–æ–¹å¼æä¾›äº†ç”Ÿæˆçš„Typstä»£ç 
            # åœ¨å®é™…å®ç°ä¸­ï¼Œæ‚¨éœ€è¦è®¾è®¡ä¸€ç§æ–¹å¼è®©AIå°†ç”Ÿæˆçš„ä»£ç ä¼ é€’å›æ¥
            
            # ç”Ÿæˆæœ€ç»ˆçš„Typstæ–‡ä»¶
            if not output_path:
                pdf_path = Path(session_data["pdf_path"])
                output_path = pdf_path.parent / f"{pdf_path.stem}.typ"
            
            # æ•´åˆæ‰€æœ‰é¡µé¢çš„Typstä»£ç 
            final_typst_code = self._build_final_typst(session_data)
            
            # å†™å…¥æ–‡ä»¶
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(final_typst_code)
            
            # æ¸…ç†ä¼šè¯æ•°æ®
            del self.conversion_sessions[session_id]
            
            return CallToolResult(
                content=[TextContent(
                    type="text",
                    text=f"âœ… PDFè½¬æ¢å®Œæˆï¼\n\n"
                         f"è¾“å‡ºæ–‡ä»¶: {output_path}\n"
                         f"æ€»é¡µæ•°: {session_data['total_pages']}\n\n"
                         f"è½¬æ¢è´¨é‡å¾—ç›ŠäºAIå¤§æ¨¡å‹çš„æ™ºèƒ½å¸ƒå±€è¯†åˆ«å’Œä»£ç ç”Ÿæˆã€‚"
                )]
            )
            
        except Exception as e:
            return CallToolResult(
                content=[TextContent(type="text", text=f"è½¬æ¢å®Œæˆå¤±è´¥: {str(e)}")],
                isError=True
            )
    
    def _build_final_typst(self, session_data: Dict[str, Any]) -> str:
        """æ„å»ºæœ€ç»ˆçš„Typstä»£ç """
        # è¿™é‡Œæ˜¯ä¸€ä¸ªç®€åŒ–çš„å®ç°
        # å®é™…ä¸­éœ€è¦æ ¹æ®AIç”Ÿæˆçš„ä»£ç è¿›è¡Œæ•´åˆ
        
        typst_code = """#set page(paper: "a4")
#set text(font: "SimSun", size: 12pt)
#set par(justify: true, leading: 0.65em)

"""
        
        # æ·»åŠ AIç”Ÿæˆçš„é¡µé¢ä»£ç 
        for page_num in range(1, session_data["total_pages"] + 1):
            if page_num in session_data.get("typst_pages", {}):
                typst_code += f"// ç¬¬{page_num}é¡µ\n"
                typst_code += session_data["typst_pages"][page_num]
                typst_code += "\n\n#pagebreak()\n\n"
        
        return typst_code
    
    async def run(self):
        """è¿è¡ŒMCPæœåŠ¡å™¨"""
        from mcp.server.stdio import stdio_server
        
        async with stdio_server() as (read_stream, write_stream):
            await self.server.run(read_stream, write_stream, InitializationOptions())

async def main():
    server = IntelligentPDFToTypstServer()
    await server.run()

if __name__ == "__main__":
    asyncio.run(main())
```

## ğŸ¯ ä½¿ç”¨æµç¨‹

### **1. ç”¨æˆ·åœ¨Claude Desktopä¸­çš„æ“ä½œ**

```
ç”¨æˆ·: è¯·å¸®æˆ‘å°†è¿™ä¸ªPDFè½¬æ¢ä¸ºTypstæ ¼å¼ï¼š/path/to/document.pdf

Claudeä¼šè°ƒç”¨MCPæœåŠ¡ï¼š
1. è°ƒç”¨ start_pdf_conversion å·¥å…·
2. è‡ªåŠ¨è®¿é—®é¡µé¢å›¾ç‰‡èµ„æº
3. ä½¿ç”¨å¸ƒå±€åˆ†ææç¤ºæ¨¡æ¿
4. ç”ŸæˆTypstä»£ç 
5. è°ƒç”¨ finalize_conversion å®Œæˆè½¬æ¢
```

### **2. Agentçš„AIå¤„ç†æµç¨‹**

1. **é¡µé¢å›¾ç‰‡åˆ†æ**: é€šè¿‡å¤šæ¨¡æ€èƒ½åŠ›è¯†åˆ«å¸ƒå±€ç»“æ„
2. **æ–‡æœ¬å†…å®¹ç†è§£**: ç»“åˆæå–çš„æ–‡æœ¬ä¿¡æ¯
3. **å¸ƒå±€å»ºæ¨¡**: ç†è§£é¡µé¢çš„å±‚æ¬¡ç»“æ„å’Œæ’ç‰ˆç‰¹å¾  
4. **ä»£ç ç”Ÿæˆ**: ç”Ÿæˆç¬¦åˆTypstè¯­æ³•çš„ä»£ç 
5. **è´¨é‡ä¼˜åŒ–**: ç¡®ä¿ç”Ÿæˆçš„ä»£ç èƒ½æ­£ç¡®é‡ç°åŸå¸ƒå±€

### **3. é…ç½®æ–‡ä»¶**

```json
{
  "mcpServers": {
    "intelligent-pdf-to-typst": {
      "command": "python",
      "args": ["/path/to/intelligent_pdf_server.py"],
      "env": {
        "PYTHONPATH": "/path/to/your/project"
      }
    }
  }
}
```

## âœ¨ æ ¸å¿ƒä¼˜åŠ¿

1. **å……åˆ†åˆ©ç”¨AIèƒ½åŠ›**: è®©Agentçš„å¤§æ¨¡å‹å¤„ç†æœ€å¤æ‚çš„å¸ƒå±€è¯†åˆ«å’Œä»£ç ç”Ÿæˆ
2. **æ ‡å‡†åŒ–æ¥å£**: é€šè¿‡MCPåè®®å®ç°æ ‡å‡†åŒ–çš„æœåŠ¡æ¥å£
3. **çµæ´»æ‰©å±•**: å¯ä»¥æ”¯æŒä¸åŒçš„AIæ¨¡å‹å’Œè½¬æ¢ç­–ç•¥
4. **ç”¨æˆ·å‹å¥½**: ç”¨æˆ·åªéœ€ç®€å•çš„è‡ªç„¶è¯­è¨€æŒ‡ä»¤å³å¯å®Œæˆè½¬æ¢

è¿™ç§è®¾è®¡è®©æ‚¨çš„MCPæœåŠ¡æˆä¸ºä¸€ä¸ª"æ™ºèƒ½åŠ©æ‰‹"ï¼Œè€ŒçœŸæ­£çš„"å¤§è„‘"æ˜¯Agentçš„AIå¤§æ¨¡å‹ã€‚éœ€è¦æˆ‘è¯¦ç»†å®ç°å…¶ä¸­ä»»ä½•éƒ¨åˆ†å—ï¼Ÿ

```python
"""
æ™ºèƒ½PDFè½¬Typst MCPæœåŠ¡
åˆ©ç”¨Agentçš„AIå¤§æ¨¡å‹è¿›è¡Œé¡µé¢å¸ƒå±€è¯†åˆ«å’Œä»£ç ç”Ÿæˆ
"""

import asyncio
import base64
import json
import tempfile
from pathlib import Path
from typing import Any, Dict, List, Optional

from mcp.server import Server
from mcp.server.models import InitializationOptions
from mcp.types import (
    CallToolRequest, CallToolResult, Tool, TextContent, ImageContent,
    ListResourcesRequest, ListResourcesResult, Resource,
    ReadResourceRequest, ReadResourceResult, ResourceContents,
    ListPromptsRequest, ListPromptsResult, Prompt,
    GetPromptRequest, GetPromptResult, PromptMessage
)

# å¯¼å…¥ç°æœ‰çš„PDFå¤„ç†åŠŸèƒ½
from src.core.pdf_parser import HybridPDFParser
from src.core.models import PageInfo, TextBlock, Table, Image

class IntelligentPDFToTypstServer:
    """æ™ºèƒ½PDFè½¬Typst MCPæœåŠ¡å™¨"""
    
    def __init__(self):
        self.server = Server("intelligent-pdf-to-typst")
        self.parser = HybridPDFParser()
        self.temp_files = {}  # å­˜å‚¨ä¸´æ—¶æ–‡ä»¶è·¯å¾„
        self.conversion_sessions = {}  # å­˜å‚¨è½¬æ¢ä¼šè¯æ•°æ®
        self._setup_handlers()
    
    def _setup_handlers(self):
        """è®¾ç½®MCPå¤„ç†å™¨"""
        
        @self.server.list_tools()
        async def list_tools() -> List[Tool]:
            return [
                Tool(
                    name="start_pdf_conversion",
                    description="å¼€å§‹PDFè½¬Typstè½¬æ¢æµç¨‹ï¼Œæå–é¡µé¢å¹¶å‡†å¤‡ä¾›AIåˆ†æ",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "pdf_path": {"type": "string", "description": "PDFæ–‡ä»¶è·¯å¾„"},
                            "session_id": {"type": "string", "description": "è½¬æ¢ä¼šè¯ID"}
                        },
                        "required": ["pdf_path", "session_id"]
                    }
                ),
                Tool(
                    name="finalize_conversion", 
                    description="å®Œæˆè½¬æ¢ï¼Œæ•´åˆAIç”Ÿæˆçš„Typstä»£ç å¹¶è¾“å‡ºæ–‡ä»¶",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "session_id": {"type": "string", "description": "è½¬æ¢ä¼šè¯ID"},
                            "output_path": {"type": "string", "description": "è¾“å‡ºæ–‡ä»¶è·¯å¾„"}
                        },
                        "required": ["session_id"]
                    }
                )
            ]
        
        @self.server.call_tool()
        async def call_tool(name: str, arguments: Dict[str, Any]) -> CallToolResult:
            if name == "start_pdf_conversion":
                return await self._start_conversion(arguments)
            elif name == "finalize_conversion":
                return await self._finalize_conversion(arguments)
            else:
                raise ValueError(f"Unknown tool: {name}")
        
        @self.server.list_resources()
        async def list_resources() -> List[Resource]:
            """åˆ—å‡ºå¯ç”¨çš„èµ„æºï¼ˆé¡µé¢å›¾ç‰‡ã€æ–‡æœ¬å†…å®¹ç­‰ï¼‰"""
            resources = []
            
            for session_id, session_data in self.conversion_sessions.items():
                # ä¸ºæ¯ä¸ªé¡µé¢æ·»åŠ å›¾ç‰‡èµ„æº
                for page_num in range(1, session_data["total_pages"] + 1):
                    resources.append(Resource(
                        uri=f"pdf-page://{session_id}/page-{page_num}/image",
                        name=f"ç¬¬{page_num}é¡µå›¾ç‰‡",
                        description=f"PDFç¬¬{page_num}é¡µçš„é«˜åˆ†è¾¨ç‡å›¾ç‰‡ï¼Œç”¨äºå¸ƒå±€è¯†åˆ«",
                        mimeType="image/png"
                    ))
                    
                    resources.append(Resource(
                        uri=f"pdf-page://{session_id}/page-{page_num}/text",
                        name=f"ç¬¬{page_num}é¡µæ–‡æœ¬",
                        description=f"PDFç¬¬{page_num}é¡µçš„æ–‡æœ¬å†…å®¹å’Œç»“æ„ä¿¡æ¯",
                        mimeType="application/json"
                    ))
            
            return resources
        
        @self.server.read_resource()
        async def read_resource(uri: str) -> ResourceContents:
            """è¯»å–èµ„æºå†…å®¹"""
            # è§£æURI: pdf-page://session_id/page-N/type
            parts = uri.replace("pdf-page://", "").split("/")
            session_id, page_part, resource_type = parts
            page_num = int(page_part.split("-")[1])
            
            session_data = self.conversion_sessions.get(session_id)
            if not session_data:
                raise ValueError(f"æœªæ‰¾åˆ°è½¬æ¢ä¼šè¯: {session_id}")
            
            if resource_type == "image":
                # è¿”å›é¡µé¢å›¾ç‰‡
                image_data = session_data["page_images"][page_num - 1]
                return ResourceContents(
                    uri=uri,
                    mimeType="image/png",
                    text=base64.b64encode(image_data).decode()
                )
            
            elif resource_type == "text":
                # è¿”å›é¡µé¢æ–‡æœ¬å’Œç»“æ„ä¿¡æ¯
                page_data = session_data["page_data"][page_num - 1]
                return ResourceContents(
                    uri=uri,
                    mimeType="application/json",
                    text=json.dumps(page_data, ensure_ascii=False, indent=2)
                )
            
            else:
                raise ValueError(f"æœªçŸ¥èµ„æºç±»å‹: {resource_type}")
        
        @self.server.list_prompts()
        async def list_prompts() -> List[Prompt]:
            """åˆ—å‡ºå¯ç”¨çš„æç¤ºæ¨¡æ¿"""
            return [
                Prompt(
                    name="analyze_pdf_layout",
                    description="åˆ†æPDFé¡µé¢å¸ƒå±€å¹¶ç”ŸæˆTypstä»£ç çš„æç¤ºæ¨¡æ¿"
                ),
                Prompt(
                    name="generate_typst_code",
                    description="æ ¹æ®é¡µé¢åˆ†æç»“æœç”ŸæˆTypstä»£ç çš„æç¤ºæ¨¡æ¿"
                )
            ]
        
        @self.server.get_prompt()
        async def get_prompt(name: str, arguments: Optional[Dict[str, Any]] = None) -> List[PromptMessage]:
            """è·å–æç¤ºæ¨¡æ¿å†…å®¹"""
            if name == "analyze_pdf_layout":
                return self._get_layout_analysis_prompt(arguments)
            elif name == "generate_typst_code":
                return self._get_typst_generation_prompt(arguments)
            else:
                raise ValueError(f"Unknown prompt: {name}")
    
    async def _start_conversion(self, args: Dict[str, Any]) -> CallToolResult:
        """å¼€å§‹PDFè½¬æ¢æµç¨‹"""
        pdf_path = Path(args["pdf_path"])
        session_id = args["session_id"]
        
        if not pdf_path.exists():
            raise FileNotFoundError(f"PDFæ–‡ä»¶ä¸å­˜åœ¨: {pdf_path}")
        
        try:
            # æå–PDFå…ƒæ•°æ®å’Œé¡µé¢ä¿¡æ¯
            metadata = self.parser.extract_metadata(pdf_path)
            pages_info = self.parser.get_page_info(pdf_path)
            
            # å°†æ¯é¡µè½¬æ¢ä¸ºé«˜åˆ†è¾¨ç‡å›¾ç‰‡
            page_images = await asyncio.to_thread(self._extract_page_images, pdf_path)
            
            # æå–æ¯é¡µçš„æ–‡æœ¬å’Œç»“æ„ä¿¡æ¯
            page_data = await asyncio.to_thread(self._extract_page_data, pdf_path)
            
            # å­˜å‚¨ä¼šè¯æ•°æ®
            self.conversion_sessions[session_id] = {
                "pdf_path": str(pdf_path),
                "metadata": metadata.__dict__,
                "total_pages": len(pages_info),
                "page_images": page_images,
                "page_data": page_data,
                "typst_pages": {}  # å­˜å‚¨AIç”Ÿæˆçš„æ¯é¡µTypstä»£ç 
            }
            
            # æ„å»ºè¿”å›æ¶ˆæ¯ï¼Œå¼•å¯¼AIåˆ†æé¡µé¢
            analysis_guide = self._build_analysis_guide(session_id, len(pages_info))
            
            return CallToolResult(
                content=[TextContent(
                    type="text",
                    text=f"PDFè½¬æ¢ä¼šè¯å·²å¯åŠ¨ï¼\n\n"
                         f"ğŸ“„ æ–‡æ¡£ä¿¡æ¯:\n"
                         f"- æ–‡ä»¶: {pdf_path.name}\n"
                         f"- é¡µæ•°: {len(pages_info)}\n"
                         f"- ä¼šè¯ID: {session_id}\n\n"
                         f"ğŸ” ç°åœ¨è¯·ä½¿ç”¨ä»¥ä¸‹æ­¥éª¤åˆ†æé¡µé¢å¸ƒå±€:\n\n"
                         f"{analysis_guide}"
                )]
            )
            
        except Exception as e:
            return CallToolResult(
                content=[TextContent(type="text", text=f"è½¬æ¢å¯åŠ¨å¤±è´¥: {str(e)}")],
                isError=True
            )
    
    def _build_analysis_guide(self, session_id: str, total_pages: int) -> str:
        """æ„å»ºé¡µé¢åˆ†ææŒ‡å¯¼"""
        guide = "è¯·æŒ‰ä»¥ä¸‹æ­¥éª¤åˆ†ææ¯ä¸ªé¡µé¢:\n\n"
        
        for page_num in range(1, min(total_pages + 1, 4)):  # æœ€å¤šæ˜¾ç¤ºå‰3é¡µçš„æŒ‡å¯¼
            guide += f"**ç¬¬{page_num}é¡µåˆ†æ:**\n"
            guide += f"1. æŸ¥çœ‹é¡µé¢å›¾ç‰‡: `pdf-page://{session_id}/page-{page_num}/image`\n"
            guide += f"2. æŸ¥çœ‹æ–‡æœ¬å†…å®¹: `pdf-page://{session_id}/page-{page_num}/text`\n"
            guide += f"3. ä½¿ç”¨ `analyze_pdf_layout` æç¤ºæ¨¡æ¿åˆ†æå¸ƒå±€\n"
            guide += f"4. ä½¿ç”¨ `generate_typst_code` æç¤ºæ¨¡æ¿ç”Ÿæˆä»£ç \n\n"
        
        if total_pages > 3:
            guide += f"...ä»¥åŠå…¶ä½™ {total_pages - 3} é¡µ\n\n"
        
        guide += "å®Œæˆæ‰€æœ‰é¡µé¢åˆ†æåï¼Œè¯·è°ƒç”¨ `finalize_conversion` å®Œæˆè½¬æ¢ã€‚"
        
        return guide
    
    def _get_layout_analysis_prompt(self, args: Optional[Dict[str, Any]]) -> List[PromptMessage]:
        """è·å–å¸ƒå±€åˆ†ææç¤º"""
        return [
            PromptMessage(
                role="user",
                content=TextContent(
                    type="text",
                    text="""ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„æ–‡æ¡£å¸ƒå±€åˆ†æä¸“å®¶ã€‚è¯·åˆ†æè¿™ä¸ªPDFé¡µé¢çš„å¸ƒå±€ç»“æ„ï¼ŒåŒ…æ‹¬ï¼š

1. **é¡µé¢æ•´ä½“å¸ƒå±€**: å•æ /åŒæ /å¤šæ å¸ƒå±€
2. **æ–‡æœ¬å±‚æ¬¡**: æ ‡é¢˜ã€å‰¯æ ‡é¢˜ã€æ­£æ–‡ã€å¼•ç”¨ç­‰
3. **ç‰¹æ®Šå…ƒç´ **: è¡¨æ ¼ã€å›¾ç‰‡ã€å…¬å¼ã€åˆ—è¡¨ç­‰
4. **æ’ç‰ˆç‰¹å¾**: å­—ä½“å¤§å°ã€è¡Œè·ã€æ®µè½é—´è·ã€å¯¹é½æ–¹å¼ç­‰

è¯·ç»“åˆé¡µé¢å›¾ç‰‡å’Œæ–‡æœ¬å†…å®¹ï¼Œè¾“å‡ºè¯¦ç»†çš„å¸ƒå±€åˆ†æç»“æœï¼Œæ ¼å¼å¦‚ä¸‹ï¼š

```json
{
  "layout_type": "single_column|double_column|multi_column",
  "elements": [
    {
      "type": "title|subtitle|paragraph|table|image|formula|list",
      "content": "å…ƒç´ å†…å®¹",
      "position": {"x": 0, "y": 0, "width": 0, "height": 0},
      "style": {
        "font_size": 12,
        "font_weight": "normal|bold",
        "alignment": "left|center|right|justify"
      }
    }
  ]
}
```"""
                )
            )
        ]
    
    def _get_typst_generation_prompt(self, args: Optional[Dict[str, Any]]) -> List[PromptMessage]:
        """è·å–Typstä»£ç ç”Ÿæˆæç¤º"""
        return [
            PromptMessage(
                role="user", 
                content=TextContent(
                    type="text",
                    text="""åŸºäºé¡µé¢å¸ƒå±€åˆ†æç»“æœï¼Œè¯·ç”Ÿæˆå¯¹åº”çš„Typstä»£ç ã€‚è¦æ±‚ï¼š

1. **å‡†ç¡®é‡ç°å¸ƒå±€**: ä¸¥æ ¼æŒ‰ç…§åŸé¡µé¢çš„å¸ƒå±€ç»“æ„ç”Ÿæˆä»£ç 
2. **æ­£ç¡®çš„è¯­æ³•**: ä½¿ç”¨æ­£ç¡®çš„Typstè¯­æ³•å’Œå‡½æ•°
3. **æ ·å¼åŒ¹é…**: å­—ä½“ã€å¤§å°ã€é¢œè‰²ã€å¯¹é½ç­‰æ ·å¼è¦åŒ¹é…åŸæ–‡æ¡£
4. **ç»“æ„åŒ–ä»£ç **: ä»£ç è¦æ¸…æ™°ã€æœ‰å±‚æ¬¡ã€æ˜“äºé˜…è¯»

ç”Ÿæˆçš„Typstä»£ç åº”è¯¥åŒ…æ‹¬ï¼š
- é¡µé¢è®¾ç½®ï¼ˆå°ºå¯¸ã€è¾¹è·ç­‰ï¼‰
- å­—ä½“å’Œæ ·å¼å®šä¹‰
- å†…å®¹ç»“æ„ï¼ˆæ ‡é¢˜ã€æ®µè½ã€è¡¨æ ¼ç­‰ï¼‰
- å›¾ç‰‡å¼•ç”¨ï¼ˆå¦‚æœæœ‰ï¼‰

è¯·ç›´æ¥è¾“å‡ºTypstä»£ç ï¼Œä¸éœ€è¦é¢å¤–çš„è§£é‡Šã€‚"""
                )
            )
        ]
    
    def _extract_page_images(self, pdf_path: Path) -> List[bytes]:
        """æå–é¡µé¢å›¾ç‰‡"""
        import fitz  # PyMuPDF
        
        images = []
        doc = fitz.open(pdf_path)
        
        for page_num in range(doc.page_count):
            page = doc[page_num]
            # ä»¥é«˜DPIæ¸²æŸ“é¡µé¢
            mat = fitz.Matrix(2.0, 2.0)  # 2å€ç¼©æ”¾
            pix = page.get_pixmap(matrix=mat)
            images.append(pix.tobytes("png"))
        
        doc.close()
        return images
    
    def _extract_page_data(self, pdf_path: Path) -> List[Dict[str, Any]]:
        """æå–é¡µé¢æ–‡æœ¬å’Œç»“æ„æ•°æ®"""
        text_blocks = self.parser.extract_text(pdf_path)
        tables = self.parser.extract_tables(pdf_path)
        images = self.parser.extract_images(pdf_path)
        
        # æŒ‰é¡µé¢ç»„ç»‡æ•°æ®
        pages_data = {}
        
        # ç»„ç»‡æ–‡æœ¬å—
        for block in text_blocks:
            page_num = block.page
            if page_num not in pages_data:
                pages_data[page_num] = {"text_blocks": [], "tables": [], "images": []}
            pages_data[page_num]["text_blocks"].append({
                "text": block.text,
                "bbox": [block.bbox.x0, block.bbox.y0, block.bbox.x1, block.bbox.y1],
                "font": {
                    "name": block.font.name,
                    "size": block.font.size,
                    "styles": [style.value for style in block.font.styles]
                }
            })
        
        # ç»„ç»‡è¡¨æ ¼
        for table in tables:
            page_num = table.page
            if page_num not in pages_data:
                pages_data[page_num] = {"text_blocks": [], "tables": [], "images": []}
            pages_data[page_num]["tables"].append({
                "rows": table.rows,
                "cols": table.cols,
                "cells": [{"text": cell.text, "row": cell.row, "col": cell.col} for cell in table.cells],
                "bbox": [table.bbox.x0, table.bbox.y0, table.bbox.x1, table.bbox.y1]
            })
        
        # ç»„ç»‡å›¾ç‰‡
        for image in images:
            page_num = image.page
            if page_num not in pages_data:
                pages_data[page_num] = {"text_blocks": [], "tables": [], "images": []}
            pages_data[page_num]["images"].append({
                "filename": image.filename,
                "bbox": [image.bbox.x0, image.bbox.y0, image.bbox.x1, image.bbox.y1],
                "width": image.width,
                "height": image.height
            })
        
        # è½¬æ¢ä¸ºåˆ—è¡¨æ ¼å¼
        result = []
        max_page = max(pages_data.keys()) if pages_data else 0
        
        for page_num in range(1, max_page + 1):
            result.append(pages_data.get(page_num, {"text_blocks": [], "tables": [], "images": []}))
        
        return result
    
    async def _finalize_conversion(self, args: Dict[str, Any]) -> CallToolResult:
        """å®Œæˆè½¬æ¢æµç¨‹"""
        session_id = args["session_id"]
        output_path = args.get("output_path")
        
        session_data = self.conversion_sessions.get(session_id)
        if not session_data:
            raise ValueError(f"æœªæ‰¾åˆ°è½¬æ¢ä¼šè¯: {session_id}")
        
        try:
            # è¿™é‡Œå‡è®¾AIå·²ç»é€šè¿‡å…¶ä»–æ–¹å¼æä¾›äº†ç”Ÿæˆçš„Typstä»£ç 
            # åœ¨å®é™…å®ç°ä¸­ï¼Œæ‚¨éœ€è¦è®¾è®¡ä¸€ç§æ–¹å¼è®©AIå°†ç”Ÿæˆçš„ä»£ç ä¼ é€’å›æ¥
            
            # ç”Ÿæˆæœ€ç»ˆçš„Typstæ–‡ä»¶
            if not output_path:
                pdf_path = Path(session_data["pdf_path"])
                output_path = pdf_path.parent / f"{pdf_path.stem}.typ"
            
            # æ•´åˆæ‰€æœ‰é¡µé¢çš„Typstä»£ç 
            final_typst_code = self._build_final_typst(session_data)
            
            # å†™å…¥æ–‡ä»¶
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(final_typst_code)
            
            # æ¸…ç†ä¼šè¯æ•°æ®
            del self.conversion_sessions[session_id]
            
            return CallToolResult(
                content=[TextContent(
                    type="text",
                    text=f"âœ… PDFè½¬æ¢å®Œæˆï¼\n\n"
                         f"è¾“å‡ºæ–‡ä»¶: {output_path}\n"
                         f"æ€»é¡µæ•°: {session_data['total_pages']}\n\n"
                         f"è½¬æ¢è´¨é‡å¾—ç›ŠäºAIå¤§æ¨¡å‹çš„æ™ºèƒ½å¸ƒå±€è¯†åˆ«å’Œä»£ç ç”Ÿæˆã€‚"
                )]
            )
            
        except Exception as e:
            return CallToolResult(
                content=[TextContent(type="text", text=f"è½¬æ¢å®Œæˆå¤±è´¥: {str(e)}")],
                isError=True
            )
    
    def _build_final_typst(self, session_data: Dict[str, Any]) -> str:
        """æ„å»ºæœ€ç»ˆçš„Typstä»£ç """
        # è¿™é‡Œæ˜¯ä¸€ä¸ªç®€åŒ–çš„å®ç°
        # å®é™…ä¸­éœ€è¦æ ¹æ®AIç”Ÿæˆçš„ä»£ç è¿›è¡Œæ•´åˆ
        
        typst_code = """#set page(paper: "a4")
#set text(font: "SimSun", size: 12pt)
#set par(justify: true, leading: 0.65em)

"""
        
        # æ·»åŠ AIç”Ÿæˆçš„é¡µé¢ä»£ç 
        for page_num in range(1, session_data["total_pages"] + 1):
            if page_num in session_data.get("typst_pages", {}):
                typst_code += f"// ç¬¬{page_num}é¡µ\n"
                typst_code += session_data["typst_pages"][page_num]
                typst_code += "\n\n#pagebreak()\n\n"
        
        return typst_code
    
    async def run(self):
        """è¿è¡ŒMCPæœåŠ¡å™¨"""
        from mcp.server.stdio import stdio_server
        
        async with stdio_server() as (read_stream, write_stream):
            await self.server.run(read_stream, write_stream, InitializationOptions())

async def main():
    server = IntelligentPDFToTypstServer()
    await server.run()

if __name__ == "__main__":
    asyncio.run(main())
```

## ğŸ¯ ä½¿ç”¨æµç¨‹

### **1. ç”¨æˆ·åœ¨Claude Desktopä¸­çš„æ“ä½œ**

```
ç”¨æˆ·: è¯·å¸®æˆ‘å°†è¿™ä¸ªPDFè½¬æ¢ä¸ºTypstæ ¼å¼ï¼š/path/to/document.pdf

Claudeä¼šè°ƒç”¨MCPæœåŠ¡ï¼š
1. è°ƒç”¨ start_pdf_conversion å·¥å…·
2. è‡ªåŠ¨è®¿é—®é¡µé¢å›¾ç‰‡èµ„æº
3. ä½¿ç”¨å¸ƒå±€åˆ†ææç¤ºæ¨¡æ¿
4. ç”ŸæˆTypstä»£ç 
5. è°ƒç”¨ finalize_conversion å®Œæˆè½¬æ¢
```

```json
{
  "mcpServers": {
    "intelligent-pdf-to-typst": {
      "command": "python",
      "args": ["/path/to/intelligent_pdf_server.py"],
      "env": {
        "PYTHONPATH": "/path/to/your/project"
      }
    }
  }
}
```

